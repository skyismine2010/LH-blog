<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Lh的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lh的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lh的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lh的博客">
  
    <link rel="alternate" href="/atom.xml" title="Lh的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lh的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">努力学习吧，骚年</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-redis个人源码分析笔记2(dict的实现原理)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记2(dict的实现原理)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/redis个人源码分析笔记2(dict的实现原理)/">redis个人源码分析笔记2(dict的实现原理)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1. 总体结构</strong></p>
<p>redis的dict就是hash表，使用链式结构来解决key值冲突，典型的数据结构</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672b1b02f1c2e2b?w=1261&amp;h=654&amp;f=png&amp;s=164518" alt=""></p>
<p>结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;  <span class="comment">//hash桶是一个指针数组，里面存放的是hash entry的指针类型，只需要（8字节*size）个连续内存不需要大量的连续内存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">//这个是hash桶的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">//hash桶大小-1， **用hash**/sizemask来计算桶下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">//当前这个dict一共放了多少个kv键值对</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">//一旦used/size &gt;=dict_force_resize_ratio(默认值是5)，就会触发rehash，可以理解为一个hash桶后面平均挂载的冲突队列个数为5的时候，就会触发rehash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>如下图所示：</p>
<p><strong>2. API接口分析</strong>  </p>
<p>2.1 创建</p>
<p>API接口函数：</p>
<ul>
<li>dictAdd(dict <em>d, void </em>key, void *val)</li>
</ul>
<p>在d中增加一个k-v对，实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);<span class="comment">//调用了内部函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">//如果正在rehash进行中，则每次操作都尝试进行一次rehash操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. 获取到hash桶的入口index*/</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently.</span></span><br><span class="line"><span class="comment">     （译文：申请内存来存储一个新的entry结构，插入元素到头部，</span></span><br><span class="line"><span class="comment">     这里的实现和一般的hash链式解决冲突的实现有点小不同，基于这样的假定：在数据库系统中，最近增加的entries越有可能被访问。 </span></span><br><span class="line"><span class="comment">     这里是把新插入的entry放到了链表头上，可以看上面的英文解释*/</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields.*/</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * a hash entry for the given 'key'.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned</span></span><br><span class="line"><span class="comment"> * and the optional output parameter may be filled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 这个原版注释写的很清楚，如果正在rehashing的时候，index返回的是new的hashtable*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed ，判断hash桶是否需要扩大，这个地方是redis比较牛逼的地方，  </span></span><br><span class="line"><span class="comment">    hash桶是动态扩大的，默认初始的时候只有4，然后每次乘2的方式进行扩展，如果扩展了，就需要进行rehash*/</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*获取索引的时候，如果正在rehash，需要两个hashtable都进行查询*/</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">/*这个idx就是hash桶的下标*/</span></span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="comment">/*这里是必须遍历下冲突队列，保证key没有出现过*/</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果不在rehash的话，其实就没有必要再做查找的操作了，直接返回就好了*/</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dictEntry <em>dictFind(dict </em>d, const void *key)<br>根据key在d中寻找值，这个逻辑和add差不多，代码很简单，这里就不做解释了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);  <span class="comment">//和增加的时候逻辑一样，如果正在rehashing，则进行一步rehash</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. rehash过程</strong><br>redis对于dict支持两种rehash的方式：按照时间，或者按照操作进行rehash。每次都调整一个key值桶内所有的冲突链表到新的hash表中。<br>rehash 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//redis为了保证性能，扫描空桶，最多也是有一定的限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT ，这个循环就是开始把这个rehashidx下标的hashtable迁移到新的下标下面，注意，这里需要重新计算key值，重新插入*/</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;<span class="comment">//重新计算key值，重新插入</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table...，一次操作完了，可能这个hashtable已经迁移完毕，返回0，否则返回1 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>]; <span class="comment">//现在的0变成1</span></span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);  <span class="comment">//现在的1被reset掉</span></span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记2(dict的实现原理)/" data-id="cjqes54it0001tkkpiy8ig20x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis个人源码分析笔记3(redis的事件驱动源码分析)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/">redis个人源码分析笔记3(redis的事件驱动源码分析)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="redis的事件驱动"><a href="#redis的事件驱动" class="headerlink" title="redis的事件驱动"></a>redis的事件驱动</h1><p>redis性能很好，而且是一个单线程的框架。得益于redis主要通过异步IO， 多路复用的技术，使用反应堆（reactor）模式，把大量的io操作通过消息驱动的方式单线程一条条处理，这样可以很好的利用CPU资源。因为没有同步调用，所以处理速度非常快。使得多个Client访问redis-server时候，并发性能很高。<br>那么具体redis是如何实现的呢？</p>
<h2 id="1-redis的多路复用技术"><a href="#1-redis的多路复用技术" class="headerlink" title="1 redis的多路复用技术"></a>1 redis的多路复用技术</h2><p>redis是一个C/S架构的框架，所以支持多个Client通过网络来访问Server端。redis-server为了同时支持多个client发来的数据库操作请求，使用了IO多路复用技术。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16734a2bd384a15e?w=513&amp;h=303&amp;f=png&amp;s=31507" alt="image">  </p>
<p>在一个线程里面，通过系统UNIX提供的系统API(select, poll, epoll等)，同时对n个文件描述符fd（socket也可以抽象成为文件描述符），进行读写侦听，一旦系统侦听的fd发生了 可读/可写事件的时候，通过系统API函数，可以获取到对应的fd，对于对应的文件事件进行分派，同时处理。  </p>
<blockquote>
<p>类似于一个老师（redis-server）一个人照看一个班n个学生（n个redis-cli的socket），一旦某个学生举手（socket 文件描述符发生可读可写事件），这个老师立马处理这个学生的需求（文件事件分发器），处理完了立马回来，看着一个班的n个学生，看看是不是还有人举手，周而复始的进行处理。  </p>
</blockquote>
<p>epoll， kqueue， select，evport 这几种其实都是UNIX的多路复用接口，因为redis对于类unix操作系统的兼容性其实做的比较好，所以redis对这几种接口都是支持的。对应的代码实现分别是：ae_epoll.c, ae_kqueue.c, ae_select.c, ae_evport.c.<br><img src="https://user-gold-cdn.xitu.io/2018/11/21/16734a366f6ee0f9?w=563&amp;h=222&amp;f=png&amp;s=28679" alt=""></p>
<p>因为我使用的是Ubuntu操作系统，所以本文就使用epoll为例子，看下redis的epoll的事件驱动是如何实现的。</p>
<h2 id="2-redis-的epoll源码分析"><a href="#2-redis-的epoll源码分析" class="headerlink" title="2 redis 的epoll源码分析"></a>2 redis 的epoll源码分析</h2><h2 id="2-1-redis-eventpoll-的启动初始化"><a href="#2-1-redis-eventpoll-的启动初始化" class="headerlink" title="2.1 redis eventpoll 的启动初始化"></a>2.1 redis eventpoll 的启动初始化</h2><p>在redi-server启动的时候，会走到initServer()函数中，这个函数是对<figure class="highlight plain"><figcaption><span>server; ```这个全局唯一变量的初始化，这个server的结构定义了整个server相关的所有信息，具体结构非常复杂，这里就按下不表，但是注意里面有一个结构：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">aeEventLoop *el;  //这个就是redis的所有事件循环的注册结构</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* State of an event based program */</span><br><span class="line">typedef struct aeEventLoop &#123;</span><br><span class="line">    int maxfd;   /* highest file descriptor currently registered */</span><br><span class="line">    int setsize; /* max number of file descriptors tracked */</span><br><span class="line">    long long timeEventNextId;</span><br><span class="line">    time_t lastTime;     /* Used to detect system clock skew */</span><br><span class="line">    aeFileEvent *events; /* Registered events */</span><br><span class="line">    aeFiredEvent *fired; /* Fired events */</span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    int stop;</span><br><span class="line">    void *apidata; /* This is used for polling API specific data */</span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* File event structure */</span><br><span class="line">typedef struct aeFileEvent &#123;</span><br><span class="line">    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */</span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    void *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<p>从代码上不太能看清楚里面的结构，看下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16734cb58a98cf06?w=1470&amp;h=738&amp;f=png&amp;s=195384" alt="">  </p>
<p>具体的初始化函数aeCreateEventLoop如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *aeCreateEventLoop(int setsize) &#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);</span><br><span class="line">    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(NULL);</span><br><span class="line">    eventLoop-&gt;timeEventHead = NULL;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = 0;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    eventLoop-&gt;maxfd = -1;</span><br><span class="line">    eventLoop-&gt;beforesleep = NULL;</span><br><span class="line">    eventLoop-&gt;aftersleep = NULL;</span><br><span class="line">    if (aeApiCreate(eventLoop) == -1) goto err;  //主要是初始化eventLoop-&gt;apidata</span><br><span class="line">    // Events with mask == AE_NONE are not set.</span><br><span class="line">    //So let&apos;s initialize the vector with it. </span><br><span class="line">    for (i = 0; i &lt; setsize; i++)</span><br><span class="line">       eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    return eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (eventLoop) &#123;</span><br><span class="line">     zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>aeApiCreate<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在initServer函数中，redis会根据配置尝试去侦听端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Open the TCP listening socket for the user commands. */</span><br><span class="line">if (server.port != 0 &amp;&amp;</span><br><span class="line">    listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">    exit(1);</span><br></pre></td></tr></table></figure></p>
<p>在listenToPort函数中，redis会尝试bind/listen多个ip，同时考虑了IPV4/IPV6两种场景，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listenToPort</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> *fds, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force binding of 0.0.0.0 if no bind address is specified, always</span></span><br><span class="line"><span class="comment">     * entering the loop if j == 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.bindaddr_count == <span class="number">0</span>) server.bindaddr[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.bindaddr_count || j == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.bindaddr[j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unsupported = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* Bind * for both IPv6 and IPv4, we enter here only if</span></span><br><span class="line"><span class="comment">             * server.bindaddr_count == 0. */</span></span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr,port,<span class="literal">NULL</span>,</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">            <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAFNOSUPPORT) &#123;</span><br><span class="line">                unsupported++;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Not listening to IPv6: unsupproted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (*count == <span class="number">1</span> || unsupported) &#123;</span><br><span class="line">                <span class="comment">/* Bind the IPv4 address as well. */</span></span><br><span class="line">                fds[*count] = anetTcpServer(server.neterr,port,<span class="literal">NULL</span>,</span><br><span class="line">                    server.tcp_backlog);</span><br><span class="line">                <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                    anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">                    (*count)++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAFNOSUPPORT) &#123;</span><br><span class="line">                    unsupported++;</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">"Not listening to IPv4: unsupproted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Exit the loop if we were able to bind * on IPv4 and IPv6,</span></span><br><span class="line"><span class="comment">             * otherwise fds[*count] will be ANET_ERR and we'll print an</span></span><br><span class="line"><span class="comment">             * error and return to the caller with an error. */</span></span><br><span class="line">            <span class="keyword">if</span> (*count + unsupported == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(server.bindaddr[j],<span class="string">':'</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv6 address. */</span></span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv4 address. */</span></span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fds[*count] == ANET_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Creating Server TCP listening socket %s:%d: %s"</span>,</span><br><span class="line">                server.bindaddr[j] ? server.bindaddr[j] : <span class="string">"*"</span>,</span><br><span class="line">                port, server.neterr);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建成功后，作为的server端的socket会做为文件描述符被存储在server的ipfd数组中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ipfd[CONFIG_BINDADDR_MAX]; /* TCP socket file descriptors */</span><br></pre></td></tr></table></figure></p>
<p>接着还是在initServer函数中，会为这几个server socket的ipfd 创建事件注册，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Create an event handler for accepting new connections in TCP and Unix</span><br><span class="line"> * domain sockets. */</span><br><span class="line">for (j = 0; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">    if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">        acceptTcpHandler,NULL) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            serverPanic(</span><br><span class="line">                &quot;Unrecoverable error creating server.ipfd file event.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出aeCreateFileEvent 这个函数会把文件描述符server.ipfd[i]和事件AE_READABLE，以及回调函数acceptTcpHandler做了关联，也就是每当client发来tcp建链请求事件发生时，就触发acceptTcpHandler函数。<br>下面看看这个函数到底是如何利用上面图中的数据结构，把这几样东西结合在一起的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,</span><br><span class="line">        aeFileProc *proc, void *clientData)</span><br><span class="line">&#123;</span><br><span class="line">    if (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        return AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    if (aeApiAddEvent(eventLoop, fd, mask) == -1)</span><br><span class="line">        return AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    if (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    return AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码可以看出，这个函数主要做了两件事，一个就是把事件，回调函数保存在eventLoop-&gt;events[fd]结构中。再然后就是调用了aeApiAddEvent，而这个函数其实就是epoll接口函数的一层封装。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */</span><br><span class="line">    /* If the fd was already monitored for some event, we need a MOD</span><br><span class="line">     * operation. Otherwise we need an ADD operation. */</span><br><span class="line">    int op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    ee.events = 0;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */</span><br><span class="line">    if (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码逻辑很清晰，其实核心就是调用了epoll接口中的epoll_ctl，把server socket的fd放到了epoll中进行monitor。</p>
<h2 id="2-2-redis-服务的epoll循环调用"><a href="#2-2-redis-服务的epoll循环调用" class="headerlink" title="2.2 redis 服务的epoll循环调用"></a>2.2 redis 服务的epoll循环调用</h2><p>初始化完了后，redis就会进入循环状态，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void aeMain(aeEventLoop *eventLoop) &#123;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    while (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        if (eventLoop-&gt;beforesleep != NULL)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环状态会不停的去尝试处理事件，也就是aeProcessEvents函数。这个函数会处理redis所有事件，包括文件事件和定时器事件，对于文件事件来说，核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/* Call the multiplexing API, will return only on timeout or when</span><br><span class="line">   * some event fires. */</span><br><span class="line">  numevents = aeApiPoll(eventLoop, tvp);//这里会去当前的反应堆里面看看有没待处理的事件</span><br><span class="line"></span><br><span class="line">  /* After sleep callback. */</span><br><span class="line">  if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">      eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">  for (j = 0; j &lt; numevents; j++) &#123;</span><br><span class="line">      aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">      int mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">      int fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">      int fired = 0; /* Number of events fired for current fd. */</span><br><span class="line"></span><br><span class="line">      /* Normally we execute the readable event first, and the writable</span><br><span class="line">       * event laster. This is useful as sometimes we may be able</span><br><span class="line">       * to serve the reply of a query immediately after processing the</span><br><span class="line">       * query.</span><br><span class="line">       *</span><br><span class="line">       * However if AE_BARRIER is set in the mask, our application is</span><br><span class="line">       * asking us to do the reverse: never fire the writable event</span><br><span class="line">       * after the readable. In such a case, we invert the calls.</span><br><span class="line">       * This is useful when, for instance, we want to do things</span><br><span class="line">       * in the beforeSleep() hook, like fsynching a file to disk,</span><br><span class="line">       * before replying to a client. */</span><br><span class="line">      int invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">      /* Note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already</span><br><span class="line">       * processed event removed an element that fired and we still</span><br><span class="line">       * didnt processed, so we check if the event is still valid.</span><br><span class="line">       *</span><br><span class="line">       * Fire the readable event if the call sequence is not</span><br><span class="line">       * inverted. */</span><br><span class="line">      if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">          fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">          fired++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /* Fire the writable event. */</span><br><span class="line">      if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">          if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">              fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">              fired++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /* If we have to invert the call, fire the readable event now</span><br><span class="line">       * after the writable one. */</span><br><span class="line">      if (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">          if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">              fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">              fired++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      processed++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    int retval, numevents = 0;</span><br><span class="line"></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1);</span><br><span class="line">    if (retval &gt; 0) &#123;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        for (j = 0; j &lt; numevents; j++) &#123;</span><br><span class="line">            int mask = 0;</span><br><span class="line">            struct epoll_event *e = state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次循环都会调用aeApiPoll，而这个函数其实还是epoll接口函数的一层封装，代码逻辑其实就是看看当前monitor的文件描述符是否有事件可以触发，如果有的话，就调用回调函数进行处理。</p>
<h2 id="2-3-redis-客户端建立连接和处理流程"><a href="#2-3-redis-客户端建立连接和处理流程" class="headerlink" title="2.3 redis 客户端建立连接和处理流程"></a>2.3 redis 客户端建立连接和处理流程</h2><p>在2.1小节里面已经提到了，对于server的socket 的文件描述符和AE_READABLE事件，关联了一个回调函数acceptTcpHandler，这个函数就是当server 的socket可读的时候，触发的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) &#123;</span><br><span class="line">    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    char cip[NET_IP_STR_LEN];</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line"></span><br><span class="line">    while(max--) &#123;//因为可能同时有多个client发起链接</span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);</span><br><span class="line">        if (cfd == ANET_ERR) &#123;</span><br><span class="line">            if (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          &quot;Accepting client connection: %s&quot;, server.neterr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_VERBOSE,&quot;Accepted %s:%d&quot;, cip, cport);</span><br><span class="line">        acceptCommonHandler(cfd,0,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来redis会用socket 的accept 函数去一个个的接受tcp的建链请求，然后转交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>#define MAX_ACCEPTS_PER_CALL 1000<br>static void acceptCommonHandler(int fd, int flags, char <em>ip) {<br>    client </em>c;<br>    if ((c = createClient(fd)) == NULL) {<br>        serverLog(LL_WARNING,<br>            “Error registering fd event for the new client: %s (fd=%d)”,<br>            strerror(errno),fd);<br>        close(fd); /<em> May be already closed, just ignore errors </em>/<br>        return;<br>    }<br>…后面还有一些不影响主流程，所以暂时略过不表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里会创建一个client的数据区，用来表示一个客户端，具体的逻辑如下：</span><br></pre></td></tr></table></figure>
<p>client <em>createClient(int fd) {<br>    client </em>c = zmalloc(sizeof(client));</p>
<pre><code>/* passing -1 as fd it is possible to create a non connected client.
 * This is useful since all the commands needs to be executed
 * in the context of a client. When commands are executed in other
 * contexts (for instance a Lua script) we need a non connected client. */
if (fd != -1) {
    anetNonBlock(NULL,fd);
    anetEnableTcpNoDelay(NULL,fd);
    if (server.tcpkeepalive)
        anetKeepAlive(NULL,fd,server.tcpkeepalive);
    if (aeCreateFileEvent(server.el,fd,AE_READABLE,
        readQueryFromClient, c) == AE_ERR)  
    {
        close(fd);
        zfree(c);
        return NULL;
    }
}

selectDb(c,0);
uint64_t client_id;
atomicGetIncr(server.next_client_id,client_id,1);
c-&gt;id = client_id;
c-&gt;fd = fd;
c-&gt;name = NULL;
c-&gt;bufpos = 0;
c-&gt;qb_pos = 0;
c-&gt;querybuf = sdsempty();
c-&gt;pending_querybuf = sdsempty();
c-&gt;querybuf_peak = 0;
c-&gt;reqtype = 0;
c-&gt;argc = 0;
c-&gt;argv = NULL;
c-&gt;cmd = c-&gt;lastcmd = NULL;
c-&gt;multibulklen = 0;
c-&gt;bulklen = -1;
c-&gt;sentlen = 0;
c-&gt;flags = 0;
c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;
c-&gt;authenticated = 0;
c-&gt;replstate = REPL_STATE_NONE;
c-&gt;repl_put_online_on_ack = 0;
c-&gt;reploff = 0;
c-&gt;read_reploff = 0;
c-&gt;repl_ack_off = 0;
c-&gt;repl_ack_time = 0;
c-&gt;slave_listening_port = 0;
c-&gt;slave_ip[0] = &apos;\0&apos;;
c-&gt;slave_capa = SLAVE_CAPA_NONE;
c-&gt;reply = listCreate();
c-&gt;reply_bytes = 0;
c-&gt;obuf_soft_limit_reached_time = 0;
listSetFreeMethod(c-&gt;reply,freeClientReplyValue);
listSetDupMethod(c-&gt;reply,dupClientReplyValue);
c-&gt;btype = BLOCKED_NONE;
c-&gt;bpop.timeout = 0;
c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,NULL);
c-&gt;bpop.target = NULL;
c-&gt;bpop.xread_group = NULL;
c-&gt;bpop.xread_consumer = NULL;
c-&gt;bpop.xread_group_noack = 0;
c-&gt;bpop.numreplicas = 0;
c-&gt;bpop.reploffset = 0;
c-&gt;woff = 0;
c-&gt;watched_keys = listCreate();
c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,NULL);
c-&gt;pubsub_patterns = listCreate();
c-&gt;peerid = NULL;
c-&gt;client_list_node = NULL;
listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);
listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);
if (fd != -1) linkClient(c);
initClientMultiState(c);
return c;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createClient  这个函数其实做了两件事</span><br><span class="line">- 申请内存同时初始化了client结构体； </span><br><span class="line">- 调用把客户端的socket文件描述符fd和AE_READABLE进行关联,当客户端发来消息，调用``` readQueryFromClient ```函数，放入了反应堆server.el中</span><br></pre></td></tr></table></figure></p>
<pre><code>if (aeCreateFileEvent(server.el,fd,AE_READABLE,
    readQueryFromClient, c) == AE_ERR)
{
    close(fd);
    zfree(c);
    return NULL;
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而当redis-server 收到某个客户端发来的数据库操作请求时，就会触发下面这个回调函数，这个函数中会从socket中读数据，并开始处理。</span><br></pre></td></tr></table></figure>
<p>void readQueryFromClient(aeEventLoop <em>el, int fd, void </em>privdata, int mask) {<br>    client <em>c = (client</em>) privdata;<br>    int nread, readlen;<br>    size_t qblen;<br>    UNUSED(el);<br>    UNUSED(mask);</p>
<pre><code>readlen = PROTO_IOBUF_LEN;
/* If this is a multi bulk request, and we are processing a bulk reply
 * that is large enough, try to maximize the probability that the query
 * buffer contains exactly the SDS string representing the object, even
 * at the risk of requiring more read(2) calls. This way the function
 * processMultiBulkBuffer() can avoid copying buffers to create the
 * Redis Object representing the argument. */
if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1
    &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)
{
    ssize_t remaining = (size_t)(c-&gt;bulklen+2)-sdslen(c-&gt;querybuf);

    /* Note that the &apos;remaining&apos; variable may be zero in some edge case,
     * for example once we resume a blocked client after CLIENT PAUSE. */
    if (remaining &gt; 0 &amp;&amp; remaining &lt; readlen) readlen = remaining;
}

qblen = sdslen(c-&gt;querybuf);
if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;
c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);
nread = read(fd, c-&gt;querybuf+qblen, readlen);//此处调用socket接口函数从client socket读取数据，然后进行处理
if (nread == -1) {
    if (errno == EAGAIN) {
        return;
    } else {
        serverLog(LL_VERBOSE, &quot;Reading from client: %s&quot;,strerror(errno));
        freeClient(c);
        return;
    }
} else if (nread == 0) {
    serverLog(LL_VERBOSE, &quot;Client closed connection&quot;);
    freeClient(c);
    return;
} else if (c-&gt;flags &amp; CLIENT_MASTER) {
    /* Append the query buffer to the pending (not applied) buffer
     * of the master. We&apos;ll use this buffer later in order to have a
     * copy of the string applied by the last command executed. */
    c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,
                                    c-&gt;querybuf+qblen,nread);
}

sdsIncrLen(c-&gt;querybuf,nread);
c-&gt;lastinteraction = server.unixtime;
if (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;
server.stat_net_input_bytes += nread;
if (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) {
    sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();

    bytes = sdscatrepr(bytes,c-&gt;querybuf,64);
    serverLog(LL_WARNING,&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;, ci, bytes);
    sdsfree(ci);
    sdsfree(bytes);
    freeClient(c);
    return;
}

/* Time to process the buffer. If the client is a master we need to
 * compute the difference between the applied offset before and after
 * processing the buffer, to understand how much of the replication stream
 * was actually applied to the master state: this quantity, and its
 * corresponding part of the replication stream, will be propagated to
 * the sub-slaves and to the replication backlog. */
processInputBufferAndReplicate(c);
</code></pre><p>}<br><code>`</code></p>
<p>在上面的函数中会分配一个最够大的buffer，同时调用socket接口函数从client socket读取数据，然后进行处理。最后交到<code>processInputBufferAndReplicate(c);</code> 这个函数里面会进行redis 正常命令的解析和处理。</p>
<p>至此一个基本的启动listen端口，然后提供服务，再到客户端发来建链请求，然后发来数据库操作业务消息流程就全部串起来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/" data-id="cjqes54j50003tkkp9zskb7wj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis个人源码分析笔记5(RDB持久化机制)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/">redis个人源码分析笔记5(RDB持久化机制)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1.持久化"></a>1.持久化</h1><p>大家都是知道，redis支持两种持久化的操作，AOF和RDB方式。那么为什么redis需要支持这两种持久化方式呢？其实redis的作者写过一篇文章很好的说明了为什么他要这样来进行设计，原文<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">地址</a>在这里，我也是按照这篇文章的思路结合redis的源码所做的个人总结。如果有不对的地方请指正谢谢。</p>
<p>首先要说说什么是持久化的操作。  </p>
<blockquote>
<p>持久化就是把内存中的数据写入到断电后数据不会丢失的设备中。通常说的这个设备就是硬盘。  </p>
</blockquote>
<p>一般来说一个带有持久化的写操作应该分为如下几个步骤：</p>
<ul>
<li>1.客户端发送一个数据库的写操作；（数据在客户端内存）</li>
<li>2.通过网络收到客户端发来的写操作；（数据在服务端内存）</li>
<li>3.服务端修改内存中的数据，同时调用系统函数write进行操作，将数据往磁盘中写；（数据在服务端的系统内存缓冲区）</li>
<li>4.操作系统将缓冲区中的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>5.磁盘控制器将数据写到磁盘的物理介质中（数据真正落到磁盘上）</li>
</ul>
<p>其实前面3步都是应用程序（数据库）自己能保证的，而4和5步是由操作系统来好正的。这里就不得不说下两个函数：</p>
<ul>
<li>fflush:这个函数是对一个文件描述符的操作，相当于把 自己应用程序的文件描述符中的buffers flush到OS中；</li>
<li>fsync： 这个函数就工作的更加底层了，调用这个函数其实是告诉把OS，把OS中的buffer刷新到物理设备上。  这个函数的describe是这样说的：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       sync - flush file system buffers</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       sync [OPTION]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Force changed blocks to disk, update the super block.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于一个文件描述符，其实OS为我们cache很多写操作 如果我们要求OS每次写操作都强制write来触发驱动层的话，那么所有的写操作都会变的非常慢。而fsync这个api接口是OS提供的一种折中方案，由应用自己来决定合适触发驱动层写。而且fsync不是针对某个文件描述符，而是针对整个OS。</p>
<p>我们需要分析下面两种情况的持久化问题：</p>
<ul>
<li>数据库异常崩溃</li>
<li>整个系统断电</li>
</ul>
<p>对于redis这种应用程序（数据库服务）来说，只要步骤3操作成功，即使数据库崩溃，数据也会有内核保证写入到磁盘中；<br>但是如果整个系统断电这种场景来说，必须要等到步骤5操作成功，才可认为写操作是真正的持久化成功；<br>redis是很重视整系统断电时候的性能的。所以redis有一套机制来调用sync系统函数，从而保证数据不要丢失。默认每次write了32M的数据，就回去调用一次fflush和fsync。</p>
<h2 id="2-数据损坏"><a href="#2-数据损坏" class="headerlink" title="2. 数据损坏"></a>2. 数据损坏</h2><p>其实对于一次持久化操作来说，我们不光需要考虑怎么不丢数据，还需要好好的考虑下，这个持久化下来的数据文件怎么样来保证文件格式的正确，以便重新启动的时候可以正确加载。<br>例如，很多No-SQL和SQL类型的数据库都使用树形结构来作为数据存储和索引存储的组织。但是在持久化的时候如何设计一个合理好用的持久化文件的方式，使得这个树形结构在写文件的操作中，执行到一半的时候发生了crash，也可以通过文件重新加载起来呢？<br>一般来说有三种常见的策略来进行持久化操作：</p>
<ul>
<li><strong>方法1</strong> 是最粗糙的处理，就是不通过数据的组织形式保证数据的可恢复性。而是通过配置数据同步备份的方式，在数据文件损坏后通过数据备份来进行恢复。实际上MongoDB在不开启journaling日志，通过配置Replica Sets时就是这种情况。</li>
<li><strong>方法2</strong> 是在上面基础上添加一个操作日志，每次操作时记一下操作的行为，这样我们可以通过操作日志来进行数据恢复。因为操作日志是顺序追加的方式写的，所以不会出现操作日志也无法恢复的情况。这也类似于MongoDB开启了journaling日志的情况。</li>
<li><strong>方法3</strong> 更保险的做法是数据库不进行老数据的修改，只是以追加方式去完成写操作，这样数据本身就是一份日志，这样就永远不会出现数据无法恢复的情况了。实际上CouchDB就是此做法的优秀范例。</li>
</ul>
<p>从上面的说明应该看的比较清楚了，redis的作者对于</p>
<h2 id="3-RDB方式"><a href="#3-RDB方式" class="headerlink" title="3.RDB方式"></a>3.RDB方式</h2><p>RDB方式说白了就是将当前的数据库进行一份快照，并且保存到rdb文件中进行持久化。</p>
<h3 id="3-1-RDB方式的原理"><a href="#3-1-RDB方式的原理" class="headerlink" title="3.1 RDB方式的原理"></a>3.1 RDB方式的原理</h3><p>这种方式就是第2小节说的方式1，其实是借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。</p>
<ul>
<li>redis调用fork,现在有了子进程和父进程。</li>
<li>父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出（fork一个进程入内在也被复制了，即内存会是原来的两倍）。<br>可以看出fork机制非常的适合进行快照操作，因为每次fork不会使内存增大一倍，而是动态的扩展，这个特性非常的好。</li>
</ul>
<h3 id="3-2-写RDB文件触发机制"><a href="#3-2-写RDB文件触发机制" class="headerlink" title="3.2 写RDB文件触发机制"></a>3.2 写RDB文件触发机制</h3><p>RDB的触发分为两种：</p>
<blockquote>
<p>a. 通过命令触发<br>  b. 通过条件触发<br>  c. 准备关闭数据库的时候</p>
</blockquote>
<p><strong>方式1命令触发</strong>：  SAVE 和BGSAVE命令。<br><strong>方式2条件触发</strong>： 在redis的conf配置文件中如有下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p>
<p>具体的配置在注释里面写的很详细了，其实就是两个条件都满足的时候就会触发一次快照操作。<br>当然触发也不能过于频繁，redis有一个1ms的定时器，会循环扫描看看当前的条件是否满足，如果满足了，且当前的rdb后台进程没有被触发，则开始fork进程并且dump文件。也就是说同一时刻，只会有一个RDB 后台进程在dump数据哦。当然创建了快照后，开始dump的过程中肯定会有其他的写操作进来，这时候的这部分数据在本次save操作中是没办法保存下来的。  </p>
<p><strong>方式3</strong> shutdown的时候会触发，只需要在conf配置文件中打开了save开关，就会尝试去写入一次RDB文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 3.3 写RDB文件的触发机制  </span><br><span class="line">读取文件流程发生的场景：</span><br><span class="line">-  通过debug命令加载： 通过命令```debug reload ``` 触发redis重新加载；</span><br><span class="line">-  redis服务启动的时候，触发加载；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.3 源码分析</span><br><span class="line">#### 3.3.1 save的源码分析</span><br></pre></td></tr></table></figure>
<p>void saveCommand(client <em>c) {<br>    if (server.rdb_child_pid != -1) { //如果已经在进行save，不再save<br>        addReplyError(c,”Background save already in progress”);<br>        return;<br>    }<br>    rdbSaveInfo rsi, </em>rsiptr;<br>    rsiptr = rdbPopulateSaveInfo(&amp;rsi); //生成必要的save信息<br>    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) { //在这个函数开始真正的写文件<br>        addReply(c,shared.ok);<br>    } else {<br>        addReply(c,shared.err);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">在上面的```rdbPopulateSaveInfo```函数中会生成一个rdbSaveInfo的结构指针，接着调用```rdbSave```函数进行真正的存储数据。   </span><br><span class="line">rdbSave函数实现：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* Save the DB on disk. Return C_ERR on error, C_OK on success. */</span><br><span class="line">int rdbSave(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    char tmpfile[256];</span><br><span class="line">    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    int error = 0;</span><br><span class="line"></span><br><span class="line">    snprintf(tmpfile,256,&quot;temp-%d.rdb&quot;, (int) getpid());</span><br><span class="line">    fp = fopen(tmpfile,&quot;w&quot;); //打开一个临时文件</span><br><span class="line">    if (!fp) &#123;</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span><br><span class="line">            &quot;for saving: %s&quot;,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp); //封装一个rio结构</span><br><span class="line"></span><br><span class="line">    if (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);  //如果打开了增量同步开关，每32M进行一次flush操作，在后面的流程看到这个选项的作用</span><br><span class="line">   //向文件中写</span><br><span class="line">    if (rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        goto werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Make sure data will not remain on the OS&apos;s output buffers */</span><br><span class="line">    if (fflush(fp) == EOF) goto werr;</span><br><span class="line">    if (fsync(fileno(fp)) == -1) goto werr;</span><br><span class="line">    if (fclose(fp) == EOF) goto werr;</span><br><span class="line"></span><br><span class="line">    /* Use RENAME to make sure the DB file is changed atomically only</span><br><span class="line">     * if the generate DB file is ok. */</span><br><span class="line">    if (rename(tmpfile,filename) == -1) &#123; //重命名文件，原来的rdb文件被覆盖</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Error moving temp DB file %s on the final &quot;</span><br><span class="line">            &quot;destination %s (in server root dir %s): %s&quot;,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,&quot;DB saved on disk&quot;);</span><br><span class="line">    server.dirty = 0;</span><br><span class="line">    server.lastsave = time(NULL);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    return C_OK;</span><br></pre></td></tr></table></figure>
<p>从上面的代码分析看，redis会创建一个文件描述符<figure class="highlight plain"><figcaption><span>rdb```的结构中。这个结构有什么秘密呢？我们来一起看下：   </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">struct _rio &#123;</span><br><span class="line">    /* Backend functions.</span><br><span class="line">     * Since this functions do not tolerate short writes or reads the return</span><br><span class="line">     * value is simplified to: zero on error, non zero on complete success. */</span><br><span class="line">    size_t (*read)(struct _rio *, void *buf, size_t len);</span><br><span class="line">    size_t (*write)(struct _rio *, const void *buf, size_t len);</span><br><span class="line">    off_t (*tell)(struct _rio *);</span><br><span class="line">    int (*flush)(struct _rio *);</span><br><span class="line">    /* The update_cksum method if not NULL is used to compute the checksum of</span><br><span class="line">     * all the data that was read or written so far. The method should be</span><br><span class="line">     * designed so that can be called with the current checksum, and the buf</span><br><span class="line">     * and len fields pointing to the new block of data to add to the checksum</span><br><span class="line">     * computation. */</span><br><span class="line">    void (*update_cksum)(struct _rio *, const void *buf, size_t len);</span><br><span class="line"></span><br><span class="line">    /* The current checksum */</span><br><span class="line">    uint64_t cksum;</span><br><span class="line"></span><br><span class="line">    /* number of bytes read or written */</span><br><span class="line">    size_t processed_bytes;</span><br><span class="line"></span><br><span class="line">    /* maximum single read or write chunk size */</span><br><span class="line">    size_t max_processing_chunk;</span><br><span class="line"></span><br><span class="line">    /* Backend-specific vars. */</span><br><span class="line">    union &#123;</span><br><span class="line">        /* In-memory buffer target. */</span><br><span class="line">        struct &#123;</span><br><span class="line">            sds ptr;</span><br><span class="line">            off_t pos;</span><br><span class="line">        &#125; buffer;</span><br><span class="line">        /* Stdio file pointer target. */</span><br><span class="line">        struct &#123;</span><br><span class="line">            FILE *fp;</span><br><span class="line">            off_t buffered; /* Bytes written since last fsync. */</span><br><span class="line">            off_t autosync; /* fsync after &apos;autosync&apos; bytes written. */</span><br><span class="line">        &#125; file;</span><br><span class="line">        /* Multiple FDs target (used to write to N sockets). */</span><br><span class="line">        struct &#123;</span><br><span class="line">            int *fds;       /* File descriptors. */</span><br><span class="line">            int *state;     /* Error state of each fd. 0 (if ok) or errno. */</span><br><span class="line">            int numfds;</span><br><span class="line">            off_t pos;</span><br><span class="line">            sds buf;</span><br><span class="line">        &#125; fdset;</span><br><span class="line">    &#125; io;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从结构体的注释上就能很清楚的看出来，redis的作者认为:<br>对于小数据的读写操作，<figure class="highlight plain"><figcaption><span>```write``` ```tell``` ```flush```这几个api接口函数的效率是很低的。所以这里做了对应的封装。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">具体的读写操作，redis也重新做了封装，具体的封装函数在rio.h 和rio.c里面。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* The following functions are our interface with the stream. They&apos;ll call the</span><br><span class="line"> * actual implementation of read / write / tell, and will update the checksum</span><br><span class="line"> * if needed. */</span><br><span class="line"></span><br><span class="line">static inline size_t rioWrite(rio *r, const void *buf, size_t len) &#123;</span><br><span class="line">    while (len) &#123;</span><br><span class="line">        size_t bytes_to_write = (r-&gt;max_processing_chunk &amp;&amp; r-&gt;max_processing_chunk &lt; len) ? r-&gt;max_processing_chunk : len;</span><br><span class="line">        if (r-&gt;update_cksum) r-&gt;update_cksum(r,buf,bytes_to_write);</span><br><span class="line">        if (r-&gt;write(r,buf,bytes_to_write) == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        buf = (char*)buf + bytes_to_write;</span><br><span class="line">        len -= bytes_to_write;</span><br><span class="line">        r-&gt;processed_bytes += bytes_to_write;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数看上去非常简单，就是去调用 <figure class="highlight plain"><figcaption><span>```发生一次write操作。具体的其实是调用了下面的函数：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">/* Returns 1 or 0 for success/failure. */</span><br><span class="line">static size_t rioFileWrite(rio *r, const void *buf, size_t len) &#123;</span><br><span class="line">    size_t retval;</span><br><span class="line">    //直接调用fwrite ANSI标准C函数去write</span><br><span class="line">    retval = fwrite(buf,len,1,r-&gt;io.file.fp);</span><br><span class="line">    r-&gt;io.file.buffered += len;</span><br><span class="line">    //但是是否立即flush的时候做了判断，如果达到了前面设置的阈值（默认32M）</span><br><span class="line">    //才会调用flush和fsync，要求立即写入硬盘</span><br><span class="line">    if (r-&gt;io.file.autosync &amp;&amp;</span><br><span class="line">        r-&gt;io.file.buffered &gt;= r-&gt;io.file.autosync)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(r-&gt;io.file.fp);</span><br><span class="line">        redis_fsync(fileno(r-&gt;io.file.fp));</span><br><span class="line">        r-&gt;io.file.buffered = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看出来是有条件的调用了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">而如果使用BGSAVE命令，源码：</span><br><span class="line">```C</span><br><span class="line">void bgsaveCommand(client *c) &#123;</span><br><span class="line">    int schedule = 0;</span><br><span class="line"></span><br><span class="line">    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite</span><br><span class="line">     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */</span><br><span class="line">    if (c-&gt;argc &gt; 1) &#123;</span><br><span class="line">        if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;schedule&quot;)) &#123;</span><br><span class="line">            schedule = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line"></span><br><span class="line">    if (server.rdb_child_pid != -1) &#123;//正在rdb操作，本次操作不可以进行</span><br><span class="line">        addReplyError(c,&quot;Background save already in progress&quot;);</span><br><span class="line">    &#125; else if (server.aof_child_pid != -1) &#123; //正在aof操作本次操作不可以进行</span><br><span class="line">        if (schedule) &#123;</span><br><span class="line">            server.rdb_bgsave_scheduled = 1;</span><br><span class="line">            addReplyStatus(c,&quot;Background saving scheduled&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                &quot;An AOF log rewriting in progress: can&apos;t BGSAVE right now. &quot;</span><br><span class="line">                &quot;Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever &quot;</span><br><span class="line">                &quot;possible.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,&quot;Background saving started&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    pid_t childpid;</span><br><span class="line">    long long start;</span><br><span class="line"></span><br><span class="line">    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = time(NULL);</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line"></span><br><span class="line">    start = ustime();</span><br><span class="line">    if ((childpid = fork()) == 0) &#123; //在这里去fork一个新的进程进行持久化</span><br><span class="line">        int retval;</span><br><span class="line"></span><br><span class="line">        /* Child */</span><br><span class="line">        closeListeningSockets(0);</span><br><span class="line">        redisSetProcTitle(&quot;redis-rdb-bgsave&quot;);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        if (retval == C_OK) &#123;</span><br><span class="line">            size_t private_dirty = zmalloc_get_private_dirty(-1);</span><br><span class="line"></span><br><span class="line">            if (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    &quot;RDB: %zu MB of memory used by copy-on-write&quot;,</span><br><span class="line">                    private_dirty/(1024*1024));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server.child_info_data.cow_size = private_dirty;</span><br><span class="line">            sendChildInfo(CHILD_INFO_TYPE_RDB);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? 0 : 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Parent */</span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;fork&quot;,server.stat_fork_time/1000);</span><br><span class="line">        if (childpid == -1) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            serverLog(LL_WARNING,&quot;Can&apos;t save in background: fork: %s&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            return C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,&quot;Background saving started by pid %d&quot;,childpid);</span><br><span class="line">        server.rdb_save_time_start = time(NULL);</span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK; /* unreached */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码可以看出，bgsave命令是通过fork命令来进行后台的备份，而save命令会在原有的进程上进行操作，所以save命令要慎用，一旦使用了，如果redis中存储的数据比较多，全部dump到磁盘上，会使得redis服务器卡住一会。</p>
<p>在<figure class="highlight plain"><figcaption><span>rdb```对象。这个函数里面会把redis自己封装的```read```,```write```,```tell```,```flush```的函数指针赋值到rdb对象中。真正的写文件函数在下面的这个```rdbSaveRio```函数中实现。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* Produces a dump of the database in RDB format sending it to the specified</span><br><span class="line"> * Redis I/O channel. On success C_OK is returned, otherwise C_ERR</span><br><span class="line"> * is returned and part of the output, or all the output, can be</span><br><span class="line"> * missing because of I/O errors.</span><br><span class="line"> *</span><br><span class="line"> * When the function returns C_ERR and if &apos;error&apos; is not NULL, the</span><br><span class="line"> * integer pointed by &apos;error&apos; is set to the value of errno just after the I/O</span><br><span class="line"> * error. */</span><br><span class="line"> </span><br><span class="line">int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    dictIterator *di = NULL;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    char magic[10];</span><br><span class="line">    int j;</span><br><span class="line">    uint64_t cksum;</span><br><span class="line">    size_t processed = 0;</span><br><span class="line"></span><br><span class="line">    if (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    snprintf(magic,sizeof(magic),&quot;REDIS%04d&quot;,RDB_VERSION); //文件的头是一个魔数</span><br><span class="line">    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr; </span><br><span class="line">    if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;</span><br><span class="line">    //开始遍历数据库，一个个的开始进行持久化</span><br><span class="line">    for (j = 0; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        if (dictSize(d) == 0) continue;</span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        /* Write the SELECT DB opcode */</span><br><span class="line">        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,j) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">        /* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span><br><span class="line">         * is currently the largest type we are able to represent in RDB sizes.</span><br><span class="line">         * However this does not limit the actual size of the DB to load since</span><br><span class="line">         * these sizes are just hints to resize the hash tables. */</span><br><span class="line">        uint64_t db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,db_size) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">        /* Iterate this DB writing every entry */</span><br><span class="line">        while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            long long expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            if (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">            /* When this RDB is produced as part of an AOF rewrite, move</span><br><span class="line">             * accumulated diff from parent to child while rewriting in</span><br><span class="line">             * order to have a smaller final write. */</span><br><span class="line">            if (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = NULL; /* So that we don&apos;t release it again on error. */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we are storing the replication information on disk, persist</span><br><span class="line">     * the script cache as well: on successful PSYNC after a restart, we need</span><br><span class="line">     * to be able to process any EVALSHA inside the replication backlog the</span><br><span class="line">     * master will send us. */</span><br><span class="line">    if (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            if (rdbSaveAuxField(rdb,&quot;lua&quot;,3,body-&gt;ptr,sdslen(body-&gt;ptr)) == -1)</span><br><span class="line">                goto werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = NULL; /* So that we don&apos;t release it again on error. */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* EOF opcode */</span><br><span class="line">    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">    /* CRC64 checksum. It will be zero if checksum computation is disabled, the</span><br><span class="line">     * loading code skips the check in this case. */</span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    if (rioWrite(rdb,&amp;cksum,8) == 0) goto werr;</span><br><span class="line">    return C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    if (error) *error = errno;</span><br><span class="line">    if (di) dictReleaseIterator(di);</span><br><span class="line">    return C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个rdb文件的头是一个9个字节的魔数，总体如下格式：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dde91d8b97674?w=950&amp;h=93&amp;f=png&amp;s=4372" alt=""></p>
<p>魔数字后面的几个字段叫做AUX，存储的是redis的版本号，创建时间，已经使用的内存等等信息。<br>存储的格式如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167ddf4ba2f83272?w=643&amp;h=63&amp;f=png&amp;s=2543" alt=""></p>
<p>其中opcode是redis自己内部定义的一个操作码，用于表示这是一个什么类型的字段。具体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special RDB opcodes (saved/loaded with rdbSaveType/rdbLoadType). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_MODULE_AUX 247   <span class="comment">/* Module auxiliary data. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_IDLE       248   <span class="comment">/* LRU idle time. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_FREQ       249   <span class="comment">/* LFU frequency. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_AUX        250   <span class="comment">/* RDB aux field. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_RESIZEDB   251   <span class="comment">/* Hash table resize hint. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EXPIRETIME_MS 252    <span class="comment">/* Expire time in milliseconds. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EXPIRETIME 253       <span class="comment">/* Old expire time in seconds. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_SELECTDB   254   <span class="comment">/* DB number of the following keys. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EOF        255   <span class="comment">/* End of the RDB file. */</span></span></span><br></pre></td></tr></table></figure></p>
<p>具体的AuxFields字段的填写代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* Save a few default AUX fields with information about the RDB generated. */</span><br><span class="line">int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;</span><br><span class="line">    int aof_preamble = (flags &amp; RDB_SAVE_AOF_PREAMBLE) != 0;</span><br><span class="line"></span><br><span class="line">    /* Add a few fields about the state when the RDB was created. */</span><br><span class="line">    if (rdbSaveAuxFieldStrStr(rdb,&quot;redis-ver&quot;,REDIS_VERSION) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;redis-bits&quot;,redis_bits) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;ctime&quot;,time(NULL)) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;used-mem&quot;,zmalloc_used_memory()) == -1) return -1;</span><br><span class="line"></span><br><span class="line">    /* Handle saving options that generate aux fields. */</span><br><span class="line">    if (rsi) &#123;</span><br><span class="line">        if (rdbSaveAuxFieldStrInt(rdb,&quot;repl-stream-db&quot;,rsi-&gt;repl_stream_db)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">        if (rdbSaveAuxFieldStrStr(rdb,&quot;repl-id&quot;,server.replid)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">        if (rdbSaveAuxFieldStrInt(rdb,&quot;repl-offset&quot;,server.master_repl_offset)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;aof-preamble&quot;,aof_preamble) == -1) return -1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained</span><br><span class="line"> * with strlen(). */</span><br><span class="line">ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) &#123;</span><br><span class="line">    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Wrapper for strlen(key) + integer type (up to long long range). */</span><br><span class="line">ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) &#123;</span><br><span class="line">    char buf[LONG_STR_SIZE];</span><br><span class="line">    int vlen = ll2string(buf,sizeof(buf),val);</span><br><span class="line">    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Save an AUX field. */</span><br><span class="line">ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) &#123;</span><br><span class="line">    ssize_t ret, len = 0;</span><br><span class="line">    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在下面的循环中，redis会遍历当前server中所有的db。然后把db中所有的dict都给保存下来,根据不同的格式，保存到文件的方式也是不一样的。<br>具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save a key-value pair, with expire time, type, key, value.</span></span><br><span class="line"><span class="comment"> * On error -1 is returned.</span></span><br><span class="line"><span class="comment"> * On success if the key was actually saved 1 is returned, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned (the key was already expired). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveKeyValuePair</span><span class="params">(rio *rdb, robj *key, robj *val, <span class="keyword">long</span> <span class="keyword">long</span> expiretime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savelru = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU;</span><br><span class="line">    <span class="keyword">int</span> savelfu = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the expire time */</span></span><br><span class="line">    <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveMillisecondTime(rdb,expiretime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the LRU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelru) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> idletime = estimateObjectIdleTime(val);</span><br><span class="line">        idletime /= <span class="number">1000</span>; <span class="comment">/* Using seconds is enough and requires less space.*/</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_IDLE) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,idletime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the LFU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelfu) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">1</span>];</span><br><span class="line">        buf[<span class="number">0</span>] = LFUDecrAndReturn(val);</span><br><span class="line">        <span class="comment">/* We can encode this in exactly two bytes: the opcode and an 8</span></span><br><span class="line"><span class="comment">         * bit counter, since the frequency is logarithmic with a 0-255 range.</span></span><br><span class="line"><span class="comment">         * Note that we do not store the halving time because to reset it</span></span><br><span class="line"><span class="comment">         * a single time when loading does not affect the frequency much. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_FREQ) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save type, key, value */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObjectType(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveStringObject(rdb,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObject(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Save the object type of object "o". */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveObjectType</span><span class="params">(rio *rdb, robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJ_STRING:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_STRING);</span><br><span class="line">    <span class="keyword">case</span> OBJ_LIST:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_SET:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INTSET)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_SET_INTSET);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_SET);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_ZSET:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_ZSET_2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_HASH:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_HASH);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_STREAM:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);</span><br><span class="line">    <span class="keyword">case</span> OBJ_MODULE:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_MODULE_2);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        serverPanic(<span class="string">"Unknown object type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* avoid warning */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-load的源码分析"><a href="#3-3-2-load的源码分析" class="headerlink" title="3.3.2 load的源码分析"></a>3.3.2 load的源码分析</h4><p>在服务启动的时候，如果conf配置文件中配置了save，那么redis就会去尝试加载一次rdb文件。源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function called at startup to load RDB or AOF file in memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadDataFromDisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime();</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadAppendOnlyFile(server.aof_filename) == C_OK)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from append only file: %.3f seconds"</span>,(<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi) == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from disk: %.3f seconds"</span>,</span><br><span class="line">                (<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Restore the replication ID / offset from the RDB file. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">                rsi.repl_id_is_set &amp;&amp;</span><br><span class="line">                rsi.repl_offset != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">                <span class="comment">/* Note that older implementations may save a repl_stream_db</span></span><br><span class="line"><span class="comment">                 * of -1 inside the RDB file in a wrong way, see more information</span></span><br><span class="line"><span class="comment">                 * in function rdbPopulateSaveInfo. */</span></span><br><span class="line">                rsi.repl_stream_db != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid,rsi.repl_id,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">                server.master_repl_offset = rsi.repl_offset;</span><br><span class="line">                <span class="comment">/* If we are a slave, create a cached master from this</span></span><br><span class="line"><span class="comment">                 * information, in order to allow partial resynchronizations</span></span><br><span class="line"><span class="comment">                 * with masters. */</span></span><br><span class="line">                replicationCacheMasterUsingMyself();</span><br><span class="line">                selectDb(server.cached_master,rsi.repl_stream_db);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal error loading the DB: %s. Exiting."</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">具体调用了```rdbLoad ```函数进行加载，这个函数实现：   </span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    startLoading(fp);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rsi,<span class="number">0</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到和read的流程一样，也是先把文件描述符封装为rio对象，然后调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">/* Load an RDB file from the rio stream &apos;rdb&apos;. On success C_OK is returned,</span><br><span class="line"> * otherwise C_ERR is returned and &apos;errno&apos; is set accordingly. */</span><br><span class="line">int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) &#123;</span><br><span class="line">    uint64_t dbid;</span><br><span class="line">    int type, rdbver;</span><br><span class="line">    redisDb *db = server.db+0;</span><br><span class="line">    char buf[1024];</span><br><span class="line"></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    if (rioRead(rdb,buf,9) == 0) goto eoferr;</span><br><span class="line">    buf[9] = &apos;\0&apos;;</span><br><span class="line">    if (memcmp(buf,&quot;REDIS&quot;,5) != 0) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;Wrong signature trying to load DB from file&quot;);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbver = atoi(buf+5);</span><br><span class="line">    if (rdbver &lt; 1 || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;Can&apos;t handle RDB format version %d&quot;,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Key-specific attributes, set by opcodes before the key type. */</span><br><span class="line">    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();</span><br><span class="line">    long long lru_clock = LRU_CLOCK();</span><br><span class="line">    </span><br><span class="line">    while(1) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line"></span><br><span class="line">        /* Read type. */</span><br><span class="line">        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;</span><br><span class="line"></span><br><span class="line">        /* Handle special types. */</span><br><span class="line">        if (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            /* EXPIRETIME: load an expire associated with the next key</span><br><span class="line">             * to load. Note that after loading an expire we need to</span><br><span class="line">             * load the actual type, and continue. */</span><br><span class="line">            expiretime = rdbLoadTime(rdb);</span><br><span class="line">            expiretime *= 1000;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            /* EXPIRETIME_MS: milliseconds precision expire times introduced</span><br><span class="line">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span><br><span class="line">            expiretime = rdbLoadMillisecondTime(rdb,rdbver);</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_FREQ) &#123;</span><br><span class="line">            /* FREQ: LFU frequency. */</span><br><span class="line">            uint8_t byte;</span><br><span class="line">            if (rioRead(rdb,&amp;byte,1) == 0) goto eoferr;</span><br><span class="line">            lfu_freq = byte;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_IDLE) &#123;</span><br><span class="line">            /* IDLE: LRU idle time. */</span><br><span class="line">            uint64_t qword;</span><br><span class="line">            if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;</span><br><span class="line">            lru_idle = qword;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            /* EOF: End of file, exit the main loop. */</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            /* SELECTDB: Select the specified database. */</span><br><span class="line">            if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;</span><br><span class="line">            if (dbid &gt;= (unsigned)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;FATAL: Data file was created with a Redis &quot;</span><br><span class="line">                    &quot;server configured to handle more than %d &quot;</span><br><span class="line">                    &quot;databases. Exiting\n&quot;, server.dbnum);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            /* RESIZEDB: Hint about the size of the keys in the currently</span><br><span class="line">             * selected data base, in order to avoid useless rehashing. */</span><br><span class="line">            uint64_t db_size, expires_size;</span><br><span class="line">            if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)</span><br><span class="line">                goto eoferr;</span><br><span class="line">            if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)</span><br><span class="line">                goto eoferr;</span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            /* AUX: generic string-string fields. Use to add state to RDB</span><br><span class="line">             * which is backward compatible. Implementations of RDB loading</span><br><span class="line">             * are requierd to skip AUX fields they don&apos;t understand.</span><br><span class="line">             *</span><br><span class="line">             * An AUX field is composed of two strings: key and value. */</span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line">            if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line"></span><br><span class="line">            if (((char*)auxkey-&gt;ptr)[0] == &apos;%&apos;) &#123;</span><br><span class="line">                /* All the fields with a name staring with &apos;%&apos; are considered</span><br><span class="line">                 * information fields and are logged at startup with a log</span><br><span class="line">                 * level of NOTICE. */</span><br><span class="line">                serverLog(LL_NOTICE,&quot;RDB &apos;%s&apos;: %s&quot;,</span><br><span class="line">                    (char*)auxkey-&gt;ptr,</span><br><span class="line">                    (char*)auxval-&gt;ptr);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-stream-db&quot;)) &#123;</span><br><span class="line">                if (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-id&quot;)) &#123;</span><br><span class="line">                if (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    memcpy(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+1);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-offset&quot;)) &#123;</span><br><span class="line">                if (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,NULL,10);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;lua&quot;)) &#123;</span><br><span class="line">                /* Load the script back in memory. */</span><br><span class="line">                if (luaCreateFunction(NULL,server.lua,auxval) == NULL) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        &quot;Can&apos;t load Lua script from RDB file! &quot;</span><br><span class="line">                        &quot;BODY: %s&quot;, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* We ignore fields we don&apos;t understand, as by AUX field</span><br><span class="line">                 * contract. */</span><br><span class="line">                serverLog(LL_DEBUG,&quot;Unrecognized RDB AUX field: &apos;%s&apos;&quot;,</span><br><span class="line">                    (char*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            continue; /* Read type again. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_MODULE_AUX) &#123;</span><br><span class="line">            /* This is just for compatibility with the future: we have plans</span><br><span class="line">             * to add the ability for modules to store anything in the RDB</span><br><span class="line">             * file, like data that is not related to the Redis key space.</span><br><span class="line">             * Such data will potentially be stored both before and after the</span><br><span class="line">             * RDB keys-values section. For this reason since RDB version 9,</span><br><span class="line">             * we have the ability to read a MODULE_AUX opcode followed by an</span><br><span class="line">             * identifier of the module, and a serialized value in &quot;MODULE V2&quot;</span><br><span class="line">             * format. */</span><br><span class="line">            uint64_t moduleid = rdbLoadLen(rdb,NULL);</span><br><span class="line">            moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">            char name[10];</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line"></span><br><span class="line">            if (!rdbCheckMode &amp;&amp; mt == NULL) &#123;</span><br><span class="line">                /* Unknown module. */</span><br><span class="line">                serverLog(LL_WARNING,&quot;The RDB file contains AUX module data I can&apos;t load: no matching module &apos;%s&apos;&quot;, name);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125; else if (!rdbCheckMode &amp;&amp; mt != NULL) &#123;</span><br><span class="line">                /* This version of Redis actually does not know what to do</span><br><span class="line">                 * with modules AUX data... */</span><br><span class="line">                serverLog(LL_WARNING,&quot;The RDB file contains AUX module data I can&apos;t load for the module &apos;%s&apos;. Probably you want to use a newer version of Redis which implements aux data callbacks&quot;, name);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* RDB check mode. */</span><br><span class="line">                robj *aux = rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line">                decrRefCount(aux);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Read key */</span><br><span class="line">        if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line">        /* Read value */</span><br><span class="line">        if ((val = rdbLoadObject(type,rdb)) == NULL) goto eoferr;</span><br><span class="line">        /* Check if the key already expired. This function is used when loading</span><br><span class="line">         * an RDB file from disk, either at startup, or when an RDB was</span><br><span class="line">         * received from the master. In the latter case, the master is</span><br><span class="line">         * responsible for key expiry. If we would expire keys here, the</span><br><span class="line">         * snapshot taken by the master may not be reflected on the slave. */</span><br><span class="line">        if (server.masterhost == NULL &amp;&amp; !loading_aof &amp;&amp; expiretime != -1 &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* Add the new object in the hash table */</span><br><span class="line">            dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">            /* Set the expire time if needed */</span><br><span class="line">            if (expiretime != -1) setExpire(NULL,db,key,expiretime);</span><br><span class="line">            </span><br><span class="line">            /* Set usage information (for eviction). */</span><br><span class="line">            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock);</span><br><span class="line"></span><br><span class="line">            /* Decrement the key refcount since dbAdd() will take its</span><br><span class="line">             * own reference. */</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Reset the state that is key-specified and is populated by</span><br><span class="line">         * opcodes before the key, so that we start from scratch again. */</span><br><span class="line">        expiretime = -1;</span><br><span class="line">        lfu_freq = -1;</span><br><span class="line">        lru_idle = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Verify the checksum if RDB version is &gt;= 5 */</span><br><span class="line">    if (rdbver &gt;= 5) &#123;</span><br><span class="line">        uint64_t cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        if (rioRead(rdb,&amp;cksum,8) == 0) goto eoferr;</span><br><span class="line">        if (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            if (cksum == 0) &#123;</span><br><span class="line">                serverLog(LL_WARNING,&quot;RDB file was saved with checksum disabled: no check performed.&quot;);</span><br><span class="line">            &#125; else if (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,&quot;Wrong RDB checksum. Aborting now.&quot;);</span><br><span class="line">                rdbExitReportCorruptRDB(&quot;RDB CRC error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK;</span><br><span class="line"></span><br><span class="line">eoferr: /* unexpected end of file is handled here with a fatal exit */</span><br><span class="line">    serverLog(LL_WARNING,&quot;Short read or OOM loading DB. Unrecoverable error, aborting now.&quot;);</span><br><span class="line">    rdbExitReportCorruptRDB(&quot;Unexpected EOF reading RDB file&quot;);</span><br><span class="line">    return C_ERR; /* Just to avoid warning */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>通过上面的源码分析看出来RDB方式有如下优缺点  </p>
<ul>
<li><p>优点：<br>1.通过fork命令创建后台子进程来进行异步操作，全量保存到文件中；  </p>
</li>
<li><p>缺点：<br>1.如果使用save命令来保存，是同步操作，因为redis是单线程，导致工作线程卡住，redis卡顿；<br>2.在fork进程后，如果再有客户端发起写操作，会导致这部分数据没有及时的同步到RDB文件中，只有等这次RDB的dump操作结束后，下一次操作的时候持久化。<br>为了解决这个问题，redis就引入了另外一种持久化方式—-AOF。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/" data-id="cjqes54je0004tkkps43us5gw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis个人源码分析笔记1(hyperloglog+golang实现)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/">redis个人源码分析笔记1----hyperloglog（golang实现）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-基数统计"><a href="#1-基数统计" class="headerlink" title="1 基数统计"></a>1 基数统计</h2><p>HLL算法用来进行基数统计。</p>
<p>什么是基数统计：例如给你一个数组[1,2,2,3,3,5,5] ,这个数组的基数是4（一共有4个不重复的元素）。 好了现在知道什么是基数统计了。<br>对于这个问题，最容易想到的办法当然是使用bitmap来实现，每个bit位表示一个数字是否出现过，比如要表示上面这串数字使用下面的bitmap来表示：</p>
<blockquote>
<p>011101</p>
</blockquote>
<p><strong>优点</strong>：相对省空间，且合并操作简单，比如上面的应用场景1， 如果想统计<strong>某2天</strong>有多少个ip地址访问，只需要把两天的bitmap结构拿出来做“或”操作即可。<br><strong>缺点</strong>： 空间复杂度还是太大，1个byte只有8个bit，也就是1个byte只能唯一表示8个IP地址（8个不同的客户）那么：<br>1k才能表示 1024 <em> 8 = 8192<br>1M才能表示 1024 </em> 1024 * 8 = 8388608 （约800多万）<br>如果商品链接很多，还需要统计每天的数据等等，每个商品每天的链接需要1M以上的内存，太大，内存扛不住。</p>
<p>相反： 使用HLL ，对于精度要求不是特别高的时候，只需要12k的内存，很神奇！！！</p>
<h2 id="2-HLL算法的原理"><a href="#2-HLL算法的原理" class="headerlink" title="2 HLL算法的原理"></a>2 HLL算法的原理</h2><p>举一个我们最熟悉的抛硬币例子，出现正反面的概率都是1/2，一直抛硬币直到出现正面，记录下投掷次数k，将这种抛硬币多次直到出现正面的过程记为一次伯努利过程，对于n次伯努利过程，我们会得到n个出现正面的投掷次数值 <figure class="highlight plain"><figcaption><span>k_1, k_2 ... k_n $```, 其中这里的最大值是```k_max```。   </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">看到这里可能有点懵逼，我们把问题缕一缕，联系我们的问题，在做基数统计的时候，其实是这么个问题：  </span><br><span class="line">&gt;现在的目标是来了一组投掷次数的数据(```$ k_1, k_2 ... k_n $```)，想要预测出，一共做了多少次伯努利过程(假设为n)，才能得到这样的数据的啊？  </span><br><span class="line"></span><br><span class="line">根据一顿数学推导---直接给结论： 用 ```$2^&#123;k_ max&#125;$ ``` 来作为n的估计值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/11/17/1671ffb131e402c2?w=506&amp;h=319&amp;f=png&amp;s=18487)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;例如：做了一组伯努利过程，发现连续出现5次反面后，出现了1次正面，请问出现这种情况，大概需要做多少次伯努利过程呢？</span><br><span class="line">答案是：   ``` $ 2^6  = 64 $``` 次实验。</span><br><span class="line"></span><br><span class="line">这个其实就是我们进行HLL基数统计的基础。</span><br><span class="line"></span><br><span class="line">回到基数统计的问题，我们需要统计一组数据中不重复元素的个数，集合中每个元素的经过hash函数后可以表示成0和1构成的二进制数串，一个二进制串可以类比为一次抛硬币实验，1是抛到正面，0是反面。二进制串中从低位开始第一个1出现的位置可以理解为抛硬币试验中第一次出现正面的抛掷次数kk，那么基于上面的结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样可以可以通过第一个1出现位置的最大值``` $ k_&#123;max&#125;k</span><br><span class="line">​max</span><br></pre></td></tr></table></figure></p>
<p>​​ 来预估总共有多少个不同的数字（整体基数）。</p>
<p>所以HLL的基本思想是利用集合中数字的比特串第一个1出现位置的最大值来预估整体基数，但是这种预估方法存在较大误差，为了改善误差情况，HLL中引入分桶平均的概念。  </p>
<blockquote>
<p>例如 同样举抛硬币的例子，如果只有一组抛硬币实验，运气较好，第一次实验过程就抛了10次才第一次抛到正面，显然根据公式推导得到的实验次数的估计误差较大；如果100个组同时进行抛硬币实验，同时运气这么好的概率就很低了，每组分别进行多次抛硬币实验，并上报各自实验过程中抛到正面的抛掷次数的最大值，就能根据100组的平均值预估整体的实验次数了。</p>
</blockquote>
<p>redis里面就是使用了分桶的原理，具体的实现原理如下：<br>首先来了一个redis object（字符串）， 经过hash后，生成了一个8字节的hash值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[redis object]--&gt;|hash function| B(64 bit)</span><br></pre></td></tr></table></figure>
<p>然后将 64个bit位的前14位作为桶的下标，这样桶大小就是<figure class="highlight plain"><figcaption><span>2^&#123;14&#125; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">后面50个bit位，相当于是随机的那个伯努利过程，我们找到1第一次出现的位置count，如果当前count比桶里面的oldcount大， 则更新oldcount=count。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.2 基数统计的应用场景</span><br><span class="line">- 1. 统计一个网站一天有多少个ip地址访问；</span><br><span class="line">- 2. 统计某个商品链接每天被多少个不同客户访问；</span><br><span class="line">- ...</span><br><span class="line"></span><br><span class="line">还有很多应用，大致就是统计类的需求其实都很明确， 不需要很准确的值，只需要一个类似的估计值即可，同时不用set来存储，因为set其实很消耗内存，希望这个统计的结构越节约内存越好。</span><br><span class="line">其实都可以用这HLL算法，节约内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.4 HyperLogLog的算法流程  </span><br><span class="line">### 1.4.1 创建一个HLL对象</span><br><span class="line">HLL的头结构体定义：</span><br></pre></td></tr></table></figure></p>
<p>struct hllhdr {<br>    char magic[4];      /<em> “HYLL” 魔数，前面4个字节表示这是一个hll对象</em>/<br>    uint8_t encoding;   /<em> 存储方式，后面会讲到，分为HLL_DENSE or HLL_SPARSE两种存储方式 </em>/<br>    uint8_t notused[3]; /<em>保留字段，因为redis是自然字节对齐的，所以空着也是空着，不如定义一下 Reserved for future use, must be zero. </em>/<br>    uint8_t card[8];    /<em>缓存的当前hll对象的基数值 Cached cardinality, little endian. </em>/<br>    uint8_t registers[]; /<em> Data bytes. 对于dense存储方式，这里就是一个12k的连续数组，对于sparse存储方式，这里长度是不定的，后面会讲到</em>/<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个hll对象：</span><br></pre></td></tr></table></figure>
<p>/* Create an HLL object. We always create the HLL using sparse encoding.</p>
<ul>
<li><p>This will be upgraded to the dense representation as needed.<br>这里英文注释其实已经写的很清楚了，默认hll对象使用sparse的编码方式，这样比较节约内存，但是sparse方式存储其实比较难以理解，代码实现也比较复杂，但是对于理解来说，其实就是对于里面hll桶的存储方式的不同，HLL算法本身逻辑上没有区别<br><em>/<br>robj </em>createHLLObject(void) {<br> robj <em>o;<br> struct hllhdr </em>hdr;<br> sds s;<br> uint8_t *p;<br> int sparselen = HLL_HDR_SIZE +</p>
<pre><code>(((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
 HLL_SPARSE_XZERO_MAX_LEN)*2);  
</code></pre><p> //头长度+(16384 + (16384-1) / 16384 * 2)，也就是2个字节，默认因为基数统计里面所有的桶都是0，用spase方式存储，只需要2个字节<br> int aux;</p>
<p> /* Populate the sparse representation with as many XZERO opcodes as</p>
<ul>
<li><p>needed to represent all the registers. <em>/<br>aux = HLL_REGISTERS;<br>s = sdsnewlen(NULL,sparselen);<br>p = (uint8_t</em>)s + HLL_HDR_SIZE;<br>while(aux) {<br> int xzero = HLL_SPARSE_XZERO_MAX_LEN;<br> if (xzero &gt; aux) xzero = aux;<br> HLL_SPARSE_XZERO_SET(p,xzero);<br> p += 2;<br> aux -= xzero;<br>}<br>serverAssert((p-(uint8_t*)s) == sparselen);</p>
<p>/<em> Create the actual object. </em>/<br>o = createObject(OBJ_STRING,s);<br>hdr = o-&gt;ptr;<br>memcpy(hdr-&gt;magic,”HYLL”,4);<br>hdr-&gt;encoding = HLL_SPARSE;<br>return o;<br>}</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3 pfadd 流程</span><br><span class="line">![image](https://user-gold-cdn.xitu.io/2018/11/17/1671ffb12da8d593?w=1200&amp;h=500&amp;f=jpeg&amp;s=26953)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.1 使用dense方式存储   </span><br><span class="line">   来一个byte流，传入 是一个void * 指针和一个长度len,</span><br><span class="line">通过```MurmurHash64A``` 函数 计算一个64位的hash值。64位的前14位（这个值是可以修改的）作为index，后面作为50位作为bit流。</span><br><span class="line">2 ^ 14 == 16384 也就是一共有16384个桶。每个桶使用6个bit存储。</span><br><span class="line"></span><br><span class="line">后面的50位bit流，如下样子：   </span><br><span class="line">```00001000....11000</span><br></pre></td></tr></table></figure>
<p>其中第一次出现1的位置我们记为count， 所以count最大值是50， 用6个bit位就够表示了。<br>2 ^ 6 = 64</p>
<p>故一个HLL对象实际用来存储的空间是16384(个桶） * (<br>每个桶6个bit) / 8 = 12288 byte。 也就是使用了约12k的内存。这个其实redis比较牛逼的地方，其实用一个字节来存的话，其实也就是16k的内存，但是为了能省4k的内存，搞出一堆。这个只是dense方式存储，相对是浪费空间的，下面讲的sparse方式存储更加节约空间。</p>
<p>计算出index(桶的下标), count(后面50个bit中第一次出现1的位置)后，下一步就是更新桶的操作。<br>根据index找到桶，然后看当前的count 是否大于oldcount，大于则更新下oldcount = count。此时为了性能考虑，是不会去统计当前的基数的，而是将HLL的头里面的一个标志位置为1，表示下次进行pfcount操作的时候，当前的缓存值已经失效了，需要重新统计缓存值。在后面pfcount流程的时候，发现这个标记为失效，就会去重新统计新的基数，放入基数缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</span><br><span class="line">int hllAdd(robj *o, unsigned char *ele, size_t elesize) &#123;</span><br><span class="line">    struct hllhdr *hdr = o-&gt;ptr;</span><br><span class="line">    switch(hdr-&gt;encoding) &#123;</span><br><span class="line">    case HLL_DENSE: return hllDenseAdd(hdr-&gt;registers,ele,elesize);</span><br><span class="line">    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);//sparse</span><br><span class="line">    default: return -1; /* Invalid representation. */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* &quot;Add&quot; the element in the dense hyperloglog data structure.</span><br><span class="line"> * Actually nothing is added, but the max 0 pattern counter of the subset</span><br><span class="line"> * the element belongs to is incremented if needed.</span><br><span class="line"> *</span><br><span class="line"> * This is just a wrapper to hllDenseSet(), performing the hashing of the</span><br><span class="line"> * element in order to retrieve the index and zero-run count. */</span><br><span class="line">int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) &#123;</span><br><span class="line">    long index;</span><br><span class="line">    uint8_t count = hllPatLen(ele,elesize,&amp;index);//index就是桶的下标， count则是后面50个bit位中1第一次出现的位置</span><br><span class="line">    /* Update the register if this element produced a longer run of zeroes. */</span><br><span class="line">    return hllDenseSet(registers,index,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* ================== Dense representation implementation  ================== */</span><br><span class="line"></span><br><span class="line">/* Low level function to set the dense HLL register at &apos;index&apos; to the</span><br><span class="line"> * specified value if the current value is smaller than &apos;count&apos;.</span><br><span class="line"> *</span><br><span class="line"> * &apos;registers&apos; is expected to have room for HLL_REGISTERS plus an</span><br><span class="line"> * additional byte on the right. This requirement is met by sds strings</span><br><span class="line"> * automatically since they are implicitly null terminated.</span><br><span class="line"> *</span><br><span class="line"> * The function always succeed, however if as a result of the operation</span><br><span class="line"> * the approximated cardinality changed, 1 is returned. Otherwise 0</span><br><span class="line"> * is returned. */</span><br><span class="line">int hllDenseSet(uint8_t *registers, long index, uint8_t count) &#123;</span><br><span class="line">    uint8_t oldcount;</span><br><span class="line">    //找到对应的index获取其中的值</span><br><span class="line">    HLL_DENSE_GET_REGISTER(oldcount,registers,index);</span><br><span class="line">    if (count &gt; oldcount) &#123; //如果新的值比老的大，就更新来的</span><br><span class="line">        HLL_DENSE_SET_REGISTER(registers,index,count);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Given a string element to add to the HyperLogLog, returns the length</span><br><span class="line"> * of the pattern 000..1 of the element hash. As a side effect &apos;regp&apos; is</span><br><span class="line"> * set to the register index this element hashes to. */</span><br><span class="line">int hllPatLen(unsigned char *ele, size_t elesize, long *regp) &#123;</span><br><span class="line">    uint64_t hash, bit, index;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    /* Count the number of zeroes starting from bit HLL_REGISTERS</span><br><span class="line">     * (that is a power of two corresponding to the first bit we don&apos;t use</span><br><span class="line">     * as index). The max run can be 64-P+1 = Q+1 bits.</span><br><span class="line">     *</span><br><span class="line">     * Note that the final &quot;1&quot; ending the sequence of zeroes must be</span><br><span class="line">     * included in the count, so if we find &quot;001&quot; the count is 3, and</span><br><span class="line">     * the smallest count possible is no zeroes at all, just a 1 bit</span><br><span class="line">     * at the first position, that is a count of 1.</span><br><span class="line">     *</span><br><span class="line">     * This may sound like inefficient, but actually in the average case</span><br><span class="line">     * there are high probabilities to find a 1 after a few iterations. */</span><br><span class="line">    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);</span><br><span class="line">    index = hash &amp; HLL_P_MASK; /* Register index. */</span><br><span class="line">    hash &gt;&gt;= HLL_P; /* Remove bits used to address the register. */</span><br><span class="line">    hash |= ((uint64_t)1&lt;&lt;HLL_Q); /* Make sure the loop terminates</span><br><span class="line">                                     and count will be &lt;= Q+1. */</span><br><span class="line">    bit = 1;</span><br><span class="line">    count = 1; /* Initialized to 1 since we count the &quot;00000...1&quot; pattern. */</span><br><span class="line">    while((hash &amp; bit) == 0) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        bit &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    *regp = (int) index;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,&quot;pf hash idx=%d, count=%d&quot;, index, count);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-pfcount流程"><a href="#3-2-pfcount流程" class="headerlink" title="3.2 pfcount流程"></a>3.2 pfcount流程</h3><p>统计基数流程，就如果cache标志位是有效的，直接返回缓存值，否则重新计算HLL的所有16384个桶，然后进行统计修正，具体的修正的原理，涉及很多的数学知识和论文，这里就不提及了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* Return the approximated cardinality of the set based on the harmonic</span><br><span class="line"> * mean of the registers values. &apos;hdr&apos; points to the start of the SDS</span><br><span class="line"> * representing the String object holding the HLL representation.</span><br><span class="line"> *</span><br><span class="line"> * If the sparse representation of the HLL object is not valid, the integer</span><br><span class="line"> * pointed by &apos;invalid&apos; is set to non-zero, otherwise it is left untouched.</span><br><span class="line"> *</span><br><span class="line"> * hllCount() supports a special internal-only encoding of HLL_RAW, that</span><br><span class="line"> * is, hdr-&gt;registers will point to an uint8_t array of HLL_REGISTERS element.</span><br><span class="line"> * This is useful in order to speedup PFCOUNT when called against multiple</span><br><span class="line"> * keys (no need to work with 6-bit integers encoding). */</span><br><span class="line">uint64_t hllCount(struct hllhdr *hdr, int *invalid) &#123;</span><br><span class="line">    double m = HLL_REGISTERS;</span><br><span class="line">    double E;</span><br><span class="line">    int j;</span><br><span class="line">    int reghisto[HLL_Q+2] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    /* Compute register histogram */</span><br><span class="line">    if (hdr-&gt;encoding == HLL_DENSE) &#123;</span><br><span class="line">        hllDenseRegHisto(hdr-&gt;registers,reghisto);</span><br><span class="line">    &#125; else if (hdr-&gt;encoding == HLL_SPARSE) &#123;</span><br><span class="line">        hllSparseRegHisto(hdr-&gt;registers,</span><br><span class="line">                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);</span><br><span class="line">    &#125; else if (hdr-&gt;encoding == HLL_RAW) &#123;</span><br><span class="line">        hllRawRegHisto(hdr-&gt;registers,reghisto);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverPanic(&quot;Unknown HyperLogLog encoding in hllCount()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Estimate cardinality form register histogram. See:</span><br><span class="line">     * &quot;New cardinality estimation algorithms for HyperLogLog sketches&quot;</span><br><span class="line">     * Otmar Ertl, arXiv:1702.01284 */</span><br><span class="line">    //这里具体的修正流程，要去看论文，就照着抄过来实现就可以了。 </span><br><span class="line">    double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);</span><br><span class="line">    for (j = HLL_Q; j &gt;= 1; --j) &#123;</span><br><span class="line">        z += reghisto[j];</span><br><span class="line">        z *= 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    z += m * hllSigma(reghisto[0]/(double)m);</span><br><span class="line">    E = llroundl(HLL_ALPHA_INF*m*m/z);</span><br><span class="line"></span><br><span class="line">    return (uint64_t) E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>其实原理是很简单的，而且里面涉及到很多的数学知识，也是不能全部看懂，不得不感慨，redis对内存的节约是真的很变态的。对于sparse模式，节约的内存更加恐怖，因为这个其实对于hll算法的原理理解其实影响不大，本文就不做详细介绍了。</p>
<p>最后贴上我用golang模仿写的一个hyperloglog代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">package goRedis</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;bytes&quot;</span><br><span class="line">	&quot;encoding/binary&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const seed = 0xadc83b19</span><br><span class="line"></span><br><span class="line">const hll_dense = 1</span><br><span class="line">const hll_sparse = 2</span><br><span class="line"></span><br><span class="line">const hll_p = 14</span><br><span class="line">const hll_q = 64 - hll_p</span><br><span class="line">const hll_registers = 1 &lt;&lt; hll_p</span><br><span class="line">const hll_p_mask = hll_registers - 1</span><br><span class="line">const hll_bits = 6</span><br><span class="line">const hll_sparse_val_max_value = 32</span><br><span class="line">const hll_alpha_inf = 0.721347520444481703680</span><br><span class="line"></span><br><span class="line">type hllhdr struct &#123;</span><br><span class="line">	magic      string</span><br><span class="line">	encoding   uint8</span><br><span class="line">	notused    [3]uint8</span><br><span class="line">	card       [8]uint64</span><br><span class="line">	registers  []byte //实际存储的，因为后面如果encoding方式采用sparse的话，长度会变化，所以使用slice比较好</span><br><span class="line">	vaildCache bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initHLL(encoding uint8) *hllhdr &#123;</span><br><span class="line">	hdr := new(hllhdr)</span><br><span class="line">	hdr.magic = &quot;HYLL&quot;</span><br><span class="line">	hdr.encoding = encoding</span><br><span class="line"></span><br><span class="line">	if encoding == hll_dense &#123;</span><br><span class="line">		hdr.registers = make([]byte, hll_registers*1) // 先简单实现下 用一个字节存6个bit</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		panic(&quot;HLL SPARSE encoding format doesn&apos;t support.&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return hdr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllDenseSet(hllObj *hllhdr, index uint64, count int) bool &#123;</span><br><span class="line">	if count &gt; int(hllObj.registers[index]) &#123;</span><br><span class="line">		hllObj.registers[index] = byte(count)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PfAddCommand(hllObj *hllhdr, val []byte) &#123;</span><br><span class="line">	index, count := hllPartLen(val)</span><br><span class="line">	if hllObj.encoding == hll_dense &#123;</span><br><span class="line">		hllDenseSet(hllObj, index, count)</span><br><span class="line">		hllObj.vaildCache = false</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		panic(&quot;HLL SPARSE encoding format doesn&apos;t support.&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllTau(x float64) float64 &#123;</span><br><span class="line">	if x == 0. || x == 1. &#123;</span><br><span class="line">		return 0.</span><br><span class="line">	&#125;</span><br><span class="line">	var zPrime float64</span><br><span class="line">	y := 1.0</span><br><span class="line">	z := 1 - x</span><br><span class="line">	for &#123;</span><br><span class="line">		x = math.Sqrt(x)</span><br><span class="line">		zPrime = z</span><br><span class="line">		y *= 0.5</span><br><span class="line">		z -= math.Pow(1-x, 2) * y</span><br><span class="line">		if zPrime == z &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return z / 3</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllDenseRegHisto(hllObj *hllhdr, reghisto *[hll_q + 2]int) &#123;</span><br><span class="line">	for i := 0; i &lt; hll_registers; i++ &#123;</span><br><span class="line">		reg := hllObj.registers[i]</span><br><span class="line">		reghisto[reg]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllSigma(x float64) float64 &#123;</span><br><span class="line">	if x == 1. &#123;</span><br><span class="line">		return math.MaxInt64</span><br><span class="line">	&#125;</span><br><span class="line">	var zPrime float64</span><br><span class="line">	y := float64(1)</span><br><span class="line">	z := x</span><br><span class="line">	for &#123;</span><br><span class="line">		x *= x</span><br><span class="line">		zPrime = z</span><br><span class="line">		z += x * y</span><br><span class="line">		y += y</span><br><span class="line">		if zPrime == z &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllCount(hllObj *hllhdr) int &#123;</span><br><span class="line">	m := float64(hll_registers)</span><br><span class="line">	var reghisto [hll_q + 2]int</span><br><span class="line">	if hllObj.encoding == hll_dense &#123;</span><br><span class="line">		hllDenseRegHisto(hllObj, &amp;reghisto)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		panic(&quot;impliment me..&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z := m * hllTau((m - (float64(reghisto[hll_q+1]))/m))</span><br><span class="line">	for j := hll_q; j &gt;= 1; j-- &#123;</span><br><span class="line">		z += float64(reghisto[j])</span><br><span class="line">		z *= 0.5</span><br><span class="line">	&#125;</span><br><span class="line">	z += m * hllSigma(float64(reghisto[0])/m)</span><br><span class="line">	E := math.Round(hll_alpha_inf * m * m / z)</span><br><span class="line"></span><br><span class="line">	return int(E)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PfCountCommand(hllObj *hllhdr) int &#123;</span><br><span class="line">	var ret int</span><br><span class="line">	if hllObj.vaildCache &#123;</span><br><span class="line">		return 0</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = hllCount(hllObj)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateHLLObject() *hllhdr &#123;</span><br><span class="line">	hdr := initHLL(hll_dense)</span><br><span class="line">	return hdr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Murmurhash(buff []byte, seed uint32) uint64 &#123;</span><br><span class="line">	buffLen := uint64(len(buff))</span><br><span class="line">	m := uint64(0xc6a4a7935bd1e995)</span><br><span class="line">	r := uint32(47)</span><br><span class="line">	h := uint64(seed) ^ (buffLen * m)</span><br><span class="line"></span><br><span class="line">	for i := uint64(0); i &lt; buffLen-(buffLen&amp;7); &#123;</span><br><span class="line">		var k uint64</span><br><span class="line">		bBuffer := bytes.NewBuffer(buff[i : i+8])</span><br><span class="line">		binary.Read(bBuffer, binary.LittleEndian, &amp;k)</span><br><span class="line"></span><br><span class="line">		k *= m</span><br><span class="line">		k ^= k &gt;&gt; r</span><br><span class="line">		k *= m</span><br><span class="line">		h ^= k</span><br><span class="line">		h *= m</span><br><span class="line"></span><br><span class="line">		binary.Write(bBuffer, binary.LittleEndian, &amp;k)</span><br><span class="line">		i += 8</span><br><span class="line">	&#125;</span><br><span class="line">	switch buffLen &amp; 7 &#123;</span><br><span class="line">	case 7:</span><br><span class="line">		h ^= uint64(buff[6]) &lt;&lt; 48</span><br><span class="line">		fallthrough</span><br><span class="line">	case 6:</span><br><span class="line">		h ^= uint64(buff[5]) &lt;&lt; 40</span><br><span class="line">		fallthrough</span><br><span class="line">	case 5:</span><br><span class="line">		h ^= uint64(buff[4]) &lt;&lt; 32</span><br><span class="line">		fallthrough</span><br><span class="line">	case 4:</span><br><span class="line">		h ^= uint64(buff[3]) &lt;&lt; 24</span><br><span class="line">		fallthrough</span><br><span class="line">	case 3:</span><br><span class="line">		h ^= uint64(buff[2]) &lt;&lt; 16</span><br><span class="line">		fallthrough</span><br><span class="line">	case 2:</span><br><span class="line">		h ^= uint64(buff[1]) &lt;&lt; 8</span><br><span class="line">		fallthrough</span><br><span class="line">	case 1:</span><br><span class="line">		h ^= uint64(buff[0])</span><br><span class="line">		fallthrough</span><br><span class="line">	default:</span><br><span class="line">		h *= m</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h ^= h &gt;&gt; r</span><br><span class="line">	h *= m</span><br><span class="line">	h ^= h &gt;&gt; r</span><br><span class="line">	return h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hllPartLen(buff []byte) (index uint64, count int) &#123;</span><br><span class="line">	hash := Murmurhash(buff, seed)</span><br><span class="line">	index = hash &amp; uint64(hll_p_mask) //这里就是取出后14个bit，作为index</span><br><span class="line">	hash &gt;&gt;= hll_p                    //右移把后面14个bit清理掉,注意这里的bit流其实是倒序的</span><br><span class="line">	hash |= uint64(1) &lt;&lt; hll_q        //当前的最高位设置1，其实是一个哨兵，避免count为0</span><br><span class="line">	bit := uint64(1)</span><br><span class="line">	count = 1</span><br><span class="line">	for (hash &amp; bit) == 0 &#123;</span><br><span class="line">		count++</span><br><span class="line">		bit &lt;&lt;= 1</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;pf hash idx=%d, count=%d\n&quot;, index, count)</span><br><span class="line"></span><br><span class="line">	return index, count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func hllSparseSet(o, index int64, count int64) &#123;</span><br><span class="line">//	if count &gt; hll_sparse_val_max_value &#123;</span><br><span class="line">//		goto promote</span><br><span class="line">//	&#125;</span><br><span class="line">//</span><br><span class="line">//promote:</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func TestAll(t *testing.T) &#123;</span><br><span class="line">	hllObj := CreateHLLObject()</span><br><span class="line">	test1 := []string&#123;&quot;apple&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;ttt&quot;, &quot;aaa&quot;&#125;</span><br><span class="line"></span><br><span class="line">	for _, str := range test1 &#123;</span><br><span class="line">		PfAddCommand(hllObj, []byte(str))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	println(PfCountCommand(hllObj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/" data-id="cjqesh8an0000y8kplnqlc2s1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis个人源码分析笔记4(hash对象的存储)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记4(hash对象的存储)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/redis个人源码分析笔记4(hash对象的存储)/">redis个人源码分析笔记4(hash对象的存储)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="redis的hash的存储"><a href="#redis的hash的存储" class="headerlink" title="redis的hash的存储"></a>redis的hash的存储</h1><h2 id="1-redis-obj基本介绍"><a href="#1-redis-obj基本介绍" class="headerlink" title="1.redis-obj基本介绍"></a>1.redis-obj基本介绍</h2><p>众所周知，redis支持5种基础数据类型，分别是：</p>
<ul>
<li>string</li>
<li>list</li>
<li>set</li>
<li>hset</li>
<li>hash</li>
</ul>
<p>每种数据类型都存在至少一种encoding方式。redis把上面几种基础类型抽象成为一个结构体叫做 <figure class="highlight plain"><figcaption><span>```   </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;   //type就是redis的基础数据类型</span><br><span class="line">    unsigned encoding:4;   //这个是具体数据类型的编码方式</span><br><span class="line">    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). */</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>本文就重点介绍下hash类型在redis中是如何存储和使用的。</p>
<h2 id="2-redis-hash类型"><a href="#2-redis-hash类型" class="headerlink" title="2. redis hash类型"></a>2. redis hash类型</h2><p>hash类型是一个可以存储多个k-v键值对的结构，典型的样子是这样的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e290371def97?w=670&amp;h=371&amp;f=png&amp;s=74908" alt=""></p>
<p>其实具体的命令查看<a href="https://redis.io/commands#hash" target="_blank" rel="noopener">redis的官方文档</a>是最方便的，但是我还是把常用的总结下，也给自己加深下影响。</p>
<h3 id="2-1-hash的典型命令"><a href="#2-1-hash的典型命令" class="headerlink" title="2.1 hash的典型命令"></a>2.1 hash的典型命令</h3><p>典型的命令格式：  </p>
<blockquote>
<p>hset  redis-obj-name  k1 v1  k2 v2 …  </p>
</blockquote>
<hr>
<blockquote>
<p>hget redis_obj_name  k1</p>
</blockquote>
<p>注意这个命令是操作hash对象的，<strong>和hset对象没有关系</strong>，不要搞混淆了。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure></p>
<p>看上去很简单，那么这个myhash对象在redis的内存中是如何存储的呢？直接上源码，大家看的比较清楚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void hsetCommand(client *c) &#123;</span><br><span class="line">    int i, created = 0;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    //首先参数必须是双数，很好理解</span><br><span class="line">    if ((c-&gt;argc % 2) == 1) &#123;</span><br><span class="line">        addReplyError(c,&quot;wrong number of arguments for HMSET&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">   //函数名称写的很清楚，找不到就创建一个redis-obj对象</span><br><span class="line">    if ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[1])) == NULL) return;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,2,c-&gt;argc-1);//这里是两点，它居然会尝试去转换下hash的type</span><br><span class="line"></span><br><span class="line">    for (i = 2; i &lt; c-&gt;argc; i += 2)</span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+1]-&gt;ptr,HASH_SET_COPY);</span><br><span class="line"></span><br><span class="line">    /* HMSET (deprecated) and HSET return value is different. */</span><br><span class="line">    char *cmdname = c-&gt;argv[0]-&gt;ptr;</span><br><span class="line">    if (cmdname[1] == &apos;s&apos; || cmdname[1] == &apos;S&apos;) &#123;</span><br><span class="line">        /* HSET */</span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* HMSET */</span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,&quot;hset&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们看看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">robj *hashTypeLookupWriteOrCreate(client *c, robj *key) &#123;</span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    if (o == NULL) &#123;</span><br><span class="line">        o = createHashObject();  //这里会去创建一个hash objecjt</span><br><span class="line">        dbAdd(c-&gt;db,key,o);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (o-&gt;type != OBJ_HASH) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *createHashObject(void) &#123;</span><br><span class="line">    unsigned char *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上面，<figure class="highlight plain"><figcaption><span>table结构来存储，为什么用压缩链表结构呢？其实不用急，还有一个函数```hashTypeTryConversion```这个函数没有看，现在再看看它的实现：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">/* Check the length of a number of objects to see if we need to convert a</span><br><span class="line"> * ziplist to a real hash. Note that we only check string encoded objects</span><br><span class="line"> * as their string length can be queried in constant time. */</span><br><span class="line"></span><br><span class="line">void hashTypeTryConversion(robj *o, robj **argv, int start, int end) &#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) return;</span><br><span class="line"></span><br><span class="line">    for (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        if (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 其实上面的注释写的很清楚，如果是ZIPLIST的编码方式，遍历下ziplist，如果当前的长度已经大于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p>
<p>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 看到这里貌似有点明白了，原来redis对于小数字，短字符串,为了能比较高效的利用内存，都保存到ziplist中，而不是直接放到hash-table结构中，当数字或者字符串超出一定的阈值时候，才会改用hash表的存储方式，这样达到节约内存的作用啊。在这里不得不感叹下redis的作者真不怕麻烦，为了能节约一点内存，可以说费劲了心思。    </span><br><span class="line">总结下，redis对于hash对象提供了两种存储方式，也就是```redisObject.encoding```变量的取值是有两个的，分别如下：</span><br><span class="line">- OBJ_ENCODING_ZIPLIST  </span><br><span class="line">- OBJ_ENCODING_HT</span><br><span class="line"></span><br><span class="line">这两种编码方式内部的数据结构是什么样子的呢？ 首先我们先看看```OBJ_ENCODING_ZIPLIST ``` 类型的存储方式</span><br><span class="line"></span><br><span class="line">## 2.2 OBJ_ENCODING_ZIPLIST存储方式</span><br><span class="line">在```createHashObject```函数中，调用了ziplist的创建函数```ziplistNew```,我们来看下这个函数的实现：</span><br></pre></td></tr></table></figure></p>
<p>/<em> Create a new empty ziplist. </em>/<br>unsigned char <em>ziplistNew(void) {<br>    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;<br>    unsigned char </em>zl = zmalloc(bytes);<br>    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);<br>    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);<br>    ZIPLIST_LENGTH(zl) = 0;<br>    zl[bytes-1] = ZIP_END;<br>    return zl;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码里面用了一堆宏，看上去不太直观，画个图看下，就很清晰了：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/11/23/1673e88b9462c329?w=662&amp;h=83&amp;f=png&amp;s=15387)</span><br><span class="line">再附上ziplist的header的注释：</span><br></pre></td></tr></table></figure>
<p>/* The size of a ziplist header: two 32 bit integers for the total</p>
<ul>
<li>bytes count and last item offset. One 16 bit integer for the number</li>
<li>of items field. */<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结合代码很轻松就应该能看懂了。</span><br><span class="line"></span><br><span class="line">再看上面的代码```hsetCommand```中，调用了```hashTypeSet```函数进行插入数据</span><br><span class="line">我们再看看对于``OBJ_ENCODING_ZIPLIST``的编码方式，如何插入数据。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>int hashTypeSet(robj *o, sds field, sds value, int flags) {<br>    int update = 0;</p>
<pre><code>if (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
    unsigned char *zl, *fptr, *vptr;

    zl = o-&gt;ptr;
    fptr = ziplistIndex(zl, ZIPLIST_HEAD);
    if (fptr != NULL) {
        fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
        if (fptr != NULL) {
            /* Grab pointer to the value (fptr points to the field) */
            vptr = ziplistNext(zl, fptr);
            serverAssert(vptr != NULL);
            update = 1;

            /* Delete value */
            zl = ziplistDelete(zl, &amp;vptr);

            /* Insert new value */
            zl = ziplistInsert(zl, vptr, (unsigned char*)value,
                    sdslen(value));
        }
    }
    o-&gt;ptr = zl;

    /* Check if the ziplist needs to be converted to a hash table */
    if (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)
        hashTypeConvert(o, OBJ_ENCODING_HT);

...
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首次插入的时候，```ziplistIndex(zl, ZIPLIST_HEAD);```函数会返回NULL</span><br></pre></td></tr></table></figure>
<p>unsigned char <em>ziplistIndex(unsigned char </em>zl, int index) {<br>    unsigned char *p;<br>    unsigned int prevlensize, prevlen = 0;<br>    if (index &lt; 0) {<br>        index = (-index)-1;<br>        p = ZIPLIST_ENTRY_TAIL(zl);<br>        if (p[0] != ZIP_END) {<br>            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);<br>            while (prevlen &gt; 0 &amp;&amp; index–) {<br>                p -= prevlen;<br>                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);<br>            }<br>        }<br>    } else {<br>        p = ZIPLIST_ENTRY_HEAD(zl);<br>        while (p[0] != ZIP_END &amp;&amp; index–) {<br>            p += zipRawEntryLength(p);<br>        }<br>    }<br>    return (p[0] == ZIP_END || index &gt; 0) ? NULL : p;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进而直接调用``ziplistPush``把field和value都插入到ziplist中。再插入过后，还再多了一次判断当前的ziplist的长度是不是大于了``server.hash_max_ziplist_entries``，如果是，就需要转换为hashtable结构存储。</span><br></pre></td></tr></table></figure>
<p>unsigned char <em>ziplistPush(unsigned char </em>zl, unsigned char <em>s, unsigned int slen, int where) {<br>    unsigned char </em>p;<br>    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);<br>    return __ziplistInsert(zl,p,s,slen);<br>}</p>
<p>unsigned char <em>__ziplistInsert(unsigned char </em>zl, unsigned char <em>p, unsigned char </em>s, unsigned int slen) {<br>    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;<br>    unsigned int prevlensize, prevlen = 0;<br>    size_t offset;<br>    int nextdiff = 0;<br>    unsigned char encoding = 0;<br>    long long value = 123456789; /<em> initialized to avoid warning. Using a value<br>                                    that is easy to see if for some reason<br>                                    we use it uninitialized. </em>/<br>    zlentry tail;</p>
<pre><code>/* Find out prevlen for the entry that is inserted. */
if (p[0] != ZIP_END) {
    ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
} else {
    unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
    if (ptail[0] != ZIP_END) {
        prevlen = zipRawEntryLength(ptail);
    }
}

/* See if the entry can be encoded */
if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
    /* &apos;encoding&apos; is set to the appropriate integer encoding */
    reqlen = zipIntSize(encoding);
} else {
    /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the
     * string length to figure out how to encode it. */
    reqlen = slen;
}
/* We need space for both the length of the previous entry and
 * the length of the payload. */
reqlen += zipStorePrevEntryLength(NULL,prevlen);
reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

/* When the insert position is not equal to the tail, we need to
 * make sure that the next entry can hold this entry&apos;s length in
 * its prevlen field. */
int forcelarge = 0;
nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
    nextdiff = 0;
    forcelarge = 1;
}

/* Store offset because a realloc may change the address of zl. */
offset = p-zl;
zl = ziplistResize(zl,curlen+reqlen+nextdiff);
p = zl+offset;

/* Apply memory move when necessary and update tail offset. */
if (p[0] != ZIP_END) {
    /* Subtract one because of the ZIP_END bytes */
    memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

    /* Encode this entry&apos;s raw length in the next entry. */
    if (forcelarge)
        zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
    else
        zipStorePrevEntryLength(p+reqlen,reqlen);

    /* Update offset for tail */
    ZIPLIST_TAIL_OFFSET(zl) =
        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

    /* When the tail contains more than one entry, we need to take
     * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
     * size of prevlen doesn&apos;t have an effect on the *tail* offset. */
    zipEntry(p+reqlen, &amp;tail);
    if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
    }
} else {
    /* This element will be the new tail. */
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
}

/* When nextdiff != 0, the raw length of the next entry has changed, so
 * we need to cascade the update throughout the ziplist */
if (nextdiff != 0) {
    offset = p-zl;
    zl = __ziplistCascadeUpdate(zl,p+reqlen);
    p = zl+offset;
}

/* Write the entry */
p += zipStorePrevEntryLength(p,prevlen);  
p += zipStoreEntryEncoding(p,encoding,slen);
if (ZIP_IS_STR(encoding)) {
    memcpy(p,s,slen);
} else {
    zipSaveInteger(p,value,encoding);
}
ZIPLIST_INCR_LENGTH(zl,1);
return zl;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">插入的时候可以看出来，redis对于ziplist的存储数据结构也是比较特殊的。一个item项的结构如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/11/23/1673f84de0b0a0cf?w=531&amp;h=58&amp;f=png&amp;s=7804)</span><br></pre></td></tr></table></figure>
<p>  p += zipStorePrevEntryLength(p,prevlen);    //计算上一个item项的长度<br>  p += zipStoreEntryEncoding(p,encoding,slen); //计算当前自己需要的编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">其中`prev_entry_length`存储的是上一个item项的长度，这个也是redis比较特殊的地方，在本次更新item的时候采取计算上一个item项的长度。</span><br><span class="line"></span><br><span class="line">encoding是当前这一项的编码方式。ziplist既然是压缩链表，本质上只是是对数字类型的压缩，字符串数字都统一转换为int8, int16, int32, int64 来存储，这样比较节约内存。</span><br><span class="line"></span><br><span class="line">具体的代码实现如下：</span><br></pre></td></tr></table></figure></p>
<p>  /<em> See if the entry can be encoded </em>/<br>    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {<br>        /<em> ‘encoding’ is set to the appropriate integer encoding </em>/<br>        reqlen = zipIntSize(encoding);<br>    } else {<br>        /* ‘encoding’ is untouched, however zipStoreEntryEncoding will use the</p>
<pre><code>     * string length to figure out how to encode it. */
    reqlen = slen;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体的```zipTryEncoding``` 代码实现：</span><br></pre></td></tr></table></figure>
<p>/* Check if string pointed to by ‘entry’ can be encoded as an integer.</p>
<ul>
<li><p>Stores the integer value in ‘v’ and its encoding in ‘encoding’. <em>/<br>int zipTryEncoding(unsigned char </em>entry, unsigned int entrylen, long long <em>v, unsigned char </em>encoding) {<br> long long value;</p>
<p> if (entrylen &gt;= 32 || entrylen == 0) return 0;<br> if (string2ll((char*)entry,entrylen,&amp;value)) {</p>
<pre><code>/* Great, the string can be encoded. Check what&apos;s the smallest
 * of our encoding types that can hold this value. */
if (value &gt;= 0 &amp;&amp; value &lt;= 12) {
    *encoding = ZIP_INT_IMM_MIN+value;
} else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) {
    *encoding = ZIP_INT_8B;
} else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) {
    *encoding = ZIP_INT_16B;
} else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) {
    *encoding = ZIP_INT_24B;
} else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) {
    *encoding = ZIP_INT_32B;
} else {
    *encoding = ZIP_INT_64B;
}
*v = value;
return 1;
</code></pre><p> }<br> return 0;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中string2ll其实就是一个atoi，但是要实现一个没bug的atoi还是很难的，看看redis的实现，觉得考虑的好全面，负数，越界都考虑清楚，感觉还是很难的。</span><br></pre></td></tr></table></figure>
<p>/* Convert a string into a long long. Returns 1 if the string could be parsed</p>
<ul>
<li>into a (non-overflowing) long long, 0 otherwise. The value will be set to</li>
<li>the parsed value when appropriate.<br>*</li>
<li>Note that this function demands that the string strictly represents</li>
<li>a long long: no spaces or other characters before or after the string</li>
<li>representing the number are accepted, nor zeroes at the start if not</li>
<li>for the string “0” representing the zero number.<br>*</li>
<li>Because of its strictness, it is safe to use this function to check if</li>
<li>you can convert a string into a long long, and obtain back the string</li>
<li><p>from the number without any loss in the string representation. <em>/<br>int string2ll(const char </em>s, size_t slen, long long <em>value) {<br> const char </em>p = s;<br> size_t plen = 0;<br> int negative = 0;<br> unsigned long long v;</p>
<p> /<em> A zero length string is not a valid number. </em>/<br> if (plen == slen)</p>
<pre><code>return 0;
</code></pre><p> /<em> Special case: first and only digit is 0. </em>/<br> if (slen == 1 &amp;&amp; p[0] == ‘0’) {</p>
<pre><code>if (value != NULL) *value = 0;
return 1;
</code></pre><p> }</p>
<p> /* Handle negative numbers: just set a flag and continue like if it</p>
<ul>
<li><p>was a positive number. Later convert into negative. */<br>if (p[0] == ‘-‘) {<br> negative = 1;<br> p++; plen++;</p>
<p> /<em> Abort on only a negative sign. </em>/<br> if (plen == slen)</p>
<pre><code>return 0;
</code></pre><p>}</p>
<p>/<em> First digit should be 1-9, otherwise the string should just be 0. </em>/<br>if (p[0] &gt;= ‘1’ &amp;&amp; p[0] &lt;= ‘9’) {<br> v = p[0]-‘0’;<br> p++; plen++;<br>} else {<br> return 0;<br>}</p>
<p>/<em> Parse all the other digits, checking for overflow at every step. </em>/<br>while (plen &lt; slen &amp;&amp; p[0] &gt;= ‘0’ &amp;&amp; p[0] &lt;= ‘9’) {<br> if (v &gt; (ULLONG_MAX / 10)) /<em> Overflow. </em>/</p>
<pre><code>return 0;
</code></pre><p> v *= 10;</p>
<p> if (v &gt; (ULLONG_MAX - (p[0]-‘0’))) /<em> Overflow. </em>/</p>
<pre><code>return 0;
</code></pre><p> v += p[0]-‘0’;</p>
<p> p++; plen++;<br>}</p>
<p>/<em> Return if not all bytes were used. </em>/<br>if (plen &lt; slen)<br> return 0;</p>
<p>/* Convert to negative if needed, and do the final overflow check when</p>
</li>
<li>converting from unsigned long long to long long. <em>/<br>if (negative) {<br> if (v &gt; ((unsigned long long)(-(LLONG_MIN+1))+1)) /</em> Overflow. */<pre><code>return 0;
</code></pre> if (value != NULL) <em>value = -v;<br>} else {<br> if (v &gt; LLONG_MAX) /</em> Overflow. */<pre><code>return 0;
</code></pre> if (value != NULL) *value = v;<br>}<br>return 1;<br>}</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其实每次更新，都会触发内存的realloc，这个地方我感觉其实还是不太好的，如果一次更新n个kv对，就需要调用realloc函数n次，感觉有点浪费啊。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2.2 OBJ_ENCODING_HT存储方式</span><br><span class="line">从上面的代码可以看出来有两种场景会触发hash obj修改encoding方式，分别如下：</span><br></pre></td></tr></table></figure>
<p>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当ziplist的entry个数小于512的时候， 还有一种场景是entry的值长度小于64的时候。当然这其实是redis的一个配置项。</span><br><span class="line"></span><br><span class="line">那么hash table存储又是什么样的结构呢？看下面的代码：</span><br></pre></td></tr></table></figure></p>
<p>void hashTypeConvertZiplist(robj *o, int enc) {<br>    serverAssert(o-&gt;encoding == OBJ_ENCODING_ZIPLIST);</p>
<pre><code>if (enc == OBJ_ENCODING_ZIPLIST) {
    /* Nothing to do... */

} else if (enc == OBJ_ENCODING_HT) {
    hashTypeIterator *hi;
    dict *dict;
    int ret;

    hi = hashTypeInitIterator(o);
    dict = dictCreate(&amp;hashDictType, NULL);

    while (hashTypeNext(hi) != C_ERR) {
        sds key, value;

        key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
        value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
        ret = dictAdd(dict, key, value);
        if (ret != DICT_OK) {
            serverLogHexDump(LL_WARNING,&quot;ziplist with dup elements dump&quot;,
                o-&gt;ptr,ziplistBlobLen(o-&gt;ptr));
            serverPanic(&quot;Ziplist corruption detected&quot;);
        }
    }
    hashTypeReleaseIterator(hi);
    zfree(o-&gt;ptr);
    o-&gt;encoding = OBJ_ENCODING_HT;
    o-&gt;ptr = dict;
} else {
    serverPanic(&quot;Unknown hash encoding&quot;);
}
</code></pre><p>}</p>
<p><code>`</code><br>可以看出会创建一个迭代器，遍历当前的ziplist结构，然后放到新创建的dict结构中。</p>
<p>关于dict的结构，可以参看之前我的一篇<a href="https://juejin.im/post/5bf27463f265da6120616d9c" target="_blank" rel="noopener">dict的数据结构分析</a>。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>hash对象的存储如果使用的编码是ZipList的时候，感觉效率是不高的，平均复杂度是<code>O(n)</code>,如果涉及到内存的连锁移动的话，最差的事件复杂度其实是<code>o(n^2)</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记4(hash对象的存储)/" data-id="cjqesjddf00001wkp1kuvxzwy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记2(dict的实现原理)/">redis个人源码分析笔记2(dict的实现原理)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/">redis个人源码分析笔记3(redis的事件驱动源码分析)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/">redis个人源码分析笔记5(RDB持久化机制)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/">redis个人源码分析笔记1----hyperloglog（golang实现）</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记4(hash对象的存储)/">redis个人源码分析笔记4(hash对象的存储)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lin-Hao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>