<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>redis个人源码分析笔记5(RDB持久化机制) | Lh的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.持久化大家都是知道，redis支持两种持久化的操作，AOF和RDB方式。那么为什么redis需要支持这两种持久化方式呢？其实redis的作者写过一篇文章很好的说明了为什么他要这样来进行设计，原文地址在这里，我也是按照这篇文章的思路结合redis的源码所做的个人总结。如果有不对的地方请指正谢谢。 首先要说说什么是持久化的操作。    持久化就是把内存中的数据写入到断电后数据不会丢失的设备中。通常">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="redis个人源码分析笔记5(RDB持久化机制)">
<meta property="og:url" content="http://yoursite.com/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/index.html">
<meta property="og:site_name" content="Lh的博客">
<meta property="og:description" content="1.持久化大家都是知道，redis支持两种持久化的操作，AOF和RDB方式。那么为什么redis需要支持这两种持久化方式呢？其实redis的作者写过一篇文章很好的说明了为什么他要这样来进行设计，原文地址在这里，我也是按照这篇文章的思路结合redis的源码所做的个人总结。如果有不对的地方请指正谢谢。 首先要说说什么是持久化的操作。    持久化就是把内存中的数据写入到断电后数据不会丢失的设备中。通常">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/24/167dde91d8b97674?w=950&h=93&f=png&s=4372">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/24/167ddf4ba2f83272?w=643&h=63&f=png&s=2543">
<meta property="og:updated_time" content="2019-01-02T06:17:55.073Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis个人源码分析笔记5(RDB持久化机制)">
<meta name="twitter:description" content="1.持久化大家都是知道，redis支持两种持久化的操作，AOF和RDB方式。那么为什么redis需要支持这两种持久化方式呢？其实redis的作者写过一篇文章很好的说明了为什么他要这样来进行设计，原文地址在这里，我也是按照这篇文章的思路结合redis的源码所做的个人总结。如果有不对的地方请指正谢谢。 首先要说说什么是持久化的操作。    持久化就是把内存中的数据写入到断电后数据不会丢失的设备中。通常">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/12/24/167dde91d8b97674?w=950&h=93&f=png&s=4372">
  
    <link rel="alternate" href="/atom.xml" title="Lh的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lh的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">努力学习吧，骚年</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-redis个人源码分析笔记5(RDB持久化机制)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/" class="article-date">
  <time datetime="2019-01-02T05:58:32.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      redis个人源码分析笔记5(RDB持久化机制)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1.持久化"></a>1.持久化</h1><p>大家都是知道，redis支持两种持久化的操作，AOF和RDB方式。那么为什么redis需要支持这两种持久化方式呢？其实redis的作者写过一篇文章很好的说明了为什么他要这样来进行设计，原文<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">地址</a>在这里，我也是按照这篇文章的思路结合redis的源码所做的个人总结。如果有不对的地方请指正谢谢。</p>
<p>首先要说说什么是持久化的操作。  </p>
<blockquote>
<p>持久化就是把内存中的数据写入到断电后数据不会丢失的设备中。通常说的这个设备就是硬盘。  </p>
</blockquote>
<p>一般来说一个带有持久化的写操作应该分为如下几个步骤：</p>
<ul>
<li>1.客户端发送一个数据库的写操作；（数据在客户端内存）</li>
<li>2.通过网络收到客户端发来的写操作；（数据在服务端内存）</li>
<li>3.服务端修改内存中的数据，同时调用系统函数write进行操作，将数据往磁盘中写；（数据在服务端的系统内存缓冲区）</li>
<li>4.操作系统将缓冲区中的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>5.磁盘控制器将数据写到磁盘的物理介质中（数据真正落到磁盘上）</li>
</ul>
<p>其实前面3步都是应用程序（数据库）自己能保证的，而4和5步是由操作系统来好正的。这里就不得不说下两个函数：</p>
<ul>
<li>fflush:这个函数是对一个文件描述符的操作，相当于把 自己应用程序的文件描述符中的buffers flush到OS中；</li>
<li>fsync： 这个函数就工作的更加底层了，调用这个函数其实是告诉把OS，把OS中的buffer刷新到物理设备上。  这个函数的describe是这样说的：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       sync - flush file system buffers</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       sync [OPTION]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Force changed blocks to disk, update the super block.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于一个文件描述符，其实OS为我们cache很多写操作 如果我们要求OS每次写操作都强制write来触发驱动层的话，那么所有的写操作都会变的非常慢。而fsync这个api接口是OS提供的一种折中方案，由应用自己来决定合适触发驱动层写。而且fsync不是针对某个文件描述符，而是针对整个OS。</p>
<p>我们需要分析下面两种情况的持久化问题：</p>
<ul>
<li>数据库异常崩溃</li>
<li>整个系统断电</li>
</ul>
<p>对于redis这种应用程序（数据库服务）来说，只要步骤3操作成功，即使数据库崩溃，数据也会有内核保证写入到磁盘中；<br>但是如果整个系统断电这种场景来说，必须要等到步骤5操作成功，才可认为写操作是真正的持久化成功；<br>redis是很重视整系统断电时候的性能的。所以redis有一套机制来调用sync系统函数，从而保证数据不要丢失。默认每次write了32M的数据，就回去调用一次fflush和fsync。</p>
<h2 id="2-数据损坏"><a href="#2-数据损坏" class="headerlink" title="2. 数据损坏"></a>2. 数据损坏</h2><p>其实对于一次持久化操作来说，我们不光需要考虑怎么不丢数据，还需要好好的考虑下，这个持久化下来的数据文件怎么样来保证文件格式的正确，以便重新启动的时候可以正确加载。<br>例如，很多No-SQL和SQL类型的数据库都使用树形结构来作为数据存储和索引存储的组织。但是在持久化的时候如何设计一个合理好用的持久化文件的方式，使得这个树形结构在写文件的操作中，执行到一半的时候发生了crash，也可以通过文件重新加载起来呢？<br>一般来说有三种常见的策略来进行持久化操作：</p>
<ul>
<li><strong>方法1</strong> 是最粗糙的处理，就是不通过数据的组织形式保证数据的可恢复性。而是通过配置数据同步备份的方式，在数据文件损坏后通过数据备份来进行恢复。实际上MongoDB在不开启journaling日志，通过配置Replica Sets时就是这种情况。</li>
<li><strong>方法2</strong> 是在上面基础上添加一个操作日志，每次操作时记一下操作的行为，这样我们可以通过操作日志来进行数据恢复。因为操作日志是顺序追加的方式写的，所以不会出现操作日志也无法恢复的情况。这也类似于MongoDB开启了journaling日志的情况。</li>
<li><strong>方法3</strong> 更保险的做法是数据库不进行老数据的修改，只是以追加方式去完成写操作，这样数据本身就是一份日志，这样就永远不会出现数据无法恢复的情况了。实际上CouchDB就是此做法的优秀范例。</li>
</ul>
<p>从上面的说明应该看的比较清楚了，redis的作者对于</p>
<h2 id="3-RDB方式"><a href="#3-RDB方式" class="headerlink" title="3.RDB方式"></a>3.RDB方式</h2><p>RDB方式说白了就是将当前的数据库进行一份快照，并且保存到rdb文件中进行持久化。</p>
<h3 id="3-1-RDB方式的原理"><a href="#3-1-RDB方式的原理" class="headerlink" title="3.1 RDB方式的原理"></a>3.1 RDB方式的原理</h3><p>这种方式就是第2小节说的方式1，其实是借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。</p>
<ul>
<li>redis调用fork,现在有了子进程和父进程。</li>
<li>父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出（fork一个进程入内在也被复制了，即内存会是原来的两倍）。<br>可以看出fork机制非常的适合进行快照操作，因为每次fork不会使内存增大一倍，而是动态的扩展，这个特性非常的好。</li>
</ul>
<h3 id="3-2-写RDB文件触发机制"><a href="#3-2-写RDB文件触发机制" class="headerlink" title="3.2 写RDB文件触发机制"></a>3.2 写RDB文件触发机制</h3><p>RDB的触发分为两种：</p>
<blockquote>
<p>a. 通过命令触发<br>  b. 通过条件触发<br>  c. 准备关闭数据库的时候</p>
</blockquote>
<p><strong>方式1命令触发</strong>：  SAVE 和BGSAVE命令。<br><strong>方式2条件触发</strong>： 在redis的conf配置文件中如有下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p>
<p>具体的配置在注释里面写的很详细了，其实就是两个条件都满足的时候就会触发一次快照操作。<br>当然触发也不能过于频繁，redis有一个1ms的定时器，会循环扫描看看当前的条件是否满足，如果满足了，且当前的rdb后台进程没有被触发，则开始fork进程并且dump文件。也就是说同一时刻，只会有一个RDB 后台进程在dump数据哦。当然创建了快照后，开始dump的过程中肯定会有其他的写操作进来，这时候的这部分数据在本次save操作中是没办法保存下来的。  </p>
<p><strong>方式3</strong> shutdown的时候会触发，只需要在conf配置文件中打开了save开关，就会尝试去写入一次RDB文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 3.3 写RDB文件的触发机制  </span><br><span class="line">读取文件流程发生的场景：</span><br><span class="line">-  通过debug命令加载： 通过命令```debug reload ``` 触发redis重新加载；</span><br><span class="line">-  redis服务启动的时候，触发加载；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.3 源码分析</span><br><span class="line">#### 3.3.1 save的源码分析</span><br></pre></td></tr></table></figure>
<p>void saveCommand(client <em>c) {<br>    if (server.rdb_child_pid != -1) { //如果已经在进行save，不再save<br>        addReplyError(c,”Background save already in progress”);<br>        return;<br>    }<br>    rdbSaveInfo rsi, </em>rsiptr;<br>    rsiptr = rdbPopulateSaveInfo(&amp;rsi); //生成必要的save信息<br>    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) { //在这个函数开始真正的写文件<br>        addReply(c,shared.ok);<br>    } else {<br>        addReply(c,shared.err);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">在上面的```rdbPopulateSaveInfo```函数中会生成一个rdbSaveInfo的结构指针，接着调用```rdbSave```函数进行真正的存储数据。   </span><br><span class="line">rdbSave函数实现：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* Save the DB on disk. Return C_ERR on error, C_OK on success. */</span><br><span class="line">int rdbSave(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    char tmpfile[256];</span><br><span class="line">    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    int error = 0;</span><br><span class="line"></span><br><span class="line">    snprintf(tmpfile,256,&quot;temp-%d.rdb&quot;, (int) getpid());</span><br><span class="line">    fp = fopen(tmpfile,&quot;w&quot;); //打开一个临时文件</span><br><span class="line">    if (!fp) &#123;</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span><br><span class="line">            &quot;for saving: %s&quot;,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp); //封装一个rio结构</span><br><span class="line"></span><br><span class="line">    if (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);  //如果打开了增量同步开关，每32M进行一次flush操作，在后面的流程看到这个选项的作用</span><br><span class="line">   //向文件中写</span><br><span class="line">    if (rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        goto werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Make sure data will not remain on the OS&apos;s output buffers */</span><br><span class="line">    if (fflush(fp) == EOF) goto werr;</span><br><span class="line">    if (fsync(fileno(fp)) == -1) goto werr;</span><br><span class="line">    if (fclose(fp) == EOF) goto werr;</span><br><span class="line"></span><br><span class="line">    /* Use RENAME to make sure the DB file is changed atomically only</span><br><span class="line">     * if the generate DB file is ok. */</span><br><span class="line">    if (rename(tmpfile,filename) == -1) &#123; //重命名文件，原来的rdb文件被覆盖</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Error moving temp DB file %s on the final &quot;</span><br><span class="line">            &quot;destination %s (in server root dir %s): %s&quot;,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,&quot;DB saved on disk&quot;);</span><br><span class="line">    server.dirty = 0;</span><br><span class="line">    server.lastsave = time(NULL);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    return C_OK;</span><br></pre></td></tr></table></figure>
<p>从上面的代码分析看，redis会创建一个文件描述符<figure class="highlight plain"><figcaption><span>rdb```的结构中。这个结构有什么秘密呢？我们来一起看下：   </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">struct _rio &#123;</span><br><span class="line">    /* Backend functions.</span><br><span class="line">     * Since this functions do not tolerate short writes or reads the return</span><br><span class="line">     * value is simplified to: zero on error, non zero on complete success. */</span><br><span class="line">    size_t (*read)(struct _rio *, void *buf, size_t len);</span><br><span class="line">    size_t (*write)(struct _rio *, const void *buf, size_t len);</span><br><span class="line">    off_t (*tell)(struct _rio *);</span><br><span class="line">    int (*flush)(struct _rio *);</span><br><span class="line">    /* The update_cksum method if not NULL is used to compute the checksum of</span><br><span class="line">     * all the data that was read or written so far. The method should be</span><br><span class="line">     * designed so that can be called with the current checksum, and the buf</span><br><span class="line">     * and len fields pointing to the new block of data to add to the checksum</span><br><span class="line">     * computation. */</span><br><span class="line">    void (*update_cksum)(struct _rio *, const void *buf, size_t len);</span><br><span class="line"></span><br><span class="line">    /* The current checksum */</span><br><span class="line">    uint64_t cksum;</span><br><span class="line"></span><br><span class="line">    /* number of bytes read or written */</span><br><span class="line">    size_t processed_bytes;</span><br><span class="line"></span><br><span class="line">    /* maximum single read or write chunk size */</span><br><span class="line">    size_t max_processing_chunk;</span><br><span class="line"></span><br><span class="line">    /* Backend-specific vars. */</span><br><span class="line">    union &#123;</span><br><span class="line">        /* In-memory buffer target. */</span><br><span class="line">        struct &#123;</span><br><span class="line">            sds ptr;</span><br><span class="line">            off_t pos;</span><br><span class="line">        &#125; buffer;</span><br><span class="line">        /* Stdio file pointer target. */</span><br><span class="line">        struct &#123;</span><br><span class="line">            FILE *fp;</span><br><span class="line">            off_t buffered; /* Bytes written since last fsync. */</span><br><span class="line">            off_t autosync; /* fsync after &apos;autosync&apos; bytes written. */</span><br><span class="line">        &#125; file;</span><br><span class="line">        /* Multiple FDs target (used to write to N sockets). */</span><br><span class="line">        struct &#123;</span><br><span class="line">            int *fds;       /* File descriptors. */</span><br><span class="line">            int *state;     /* Error state of each fd. 0 (if ok) or errno. */</span><br><span class="line">            int numfds;</span><br><span class="line">            off_t pos;</span><br><span class="line">            sds buf;</span><br><span class="line">        &#125; fdset;</span><br><span class="line">    &#125; io;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从结构体的注释上就能很清楚的看出来，redis的作者认为:<br>对于小数据的读写操作，<figure class="highlight plain"><figcaption><span>```write``` ```tell``` ```flush```这几个api接口函数的效率是很低的。所以这里做了对应的封装。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">具体的读写操作，redis也重新做了封装，具体的封装函数在rio.h 和rio.c里面。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* The following functions are our interface with the stream. They&apos;ll call the</span><br><span class="line"> * actual implementation of read / write / tell, and will update the checksum</span><br><span class="line"> * if needed. */</span><br><span class="line"></span><br><span class="line">static inline size_t rioWrite(rio *r, const void *buf, size_t len) &#123;</span><br><span class="line">    while (len) &#123;</span><br><span class="line">        size_t bytes_to_write = (r-&gt;max_processing_chunk &amp;&amp; r-&gt;max_processing_chunk &lt; len) ? r-&gt;max_processing_chunk : len;</span><br><span class="line">        if (r-&gt;update_cksum) r-&gt;update_cksum(r,buf,bytes_to_write);</span><br><span class="line">        if (r-&gt;write(r,buf,bytes_to_write) == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        buf = (char*)buf + bytes_to_write;</span><br><span class="line">        len -= bytes_to_write;</span><br><span class="line">        r-&gt;processed_bytes += bytes_to_write;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数看上去非常简单，就是去调用 <figure class="highlight plain"><figcaption><span>```发生一次write操作。具体的其实是调用了下面的函数：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">/* Returns 1 or 0 for success/failure. */</span><br><span class="line">static size_t rioFileWrite(rio *r, const void *buf, size_t len) &#123;</span><br><span class="line">    size_t retval;</span><br><span class="line">    //直接调用fwrite ANSI标准C函数去write</span><br><span class="line">    retval = fwrite(buf,len,1,r-&gt;io.file.fp);</span><br><span class="line">    r-&gt;io.file.buffered += len;</span><br><span class="line">    //但是是否立即flush的时候做了判断，如果达到了前面设置的阈值（默认32M）</span><br><span class="line">    //才会调用flush和fsync，要求立即写入硬盘</span><br><span class="line">    if (r-&gt;io.file.autosync &amp;&amp;</span><br><span class="line">        r-&gt;io.file.buffered &gt;= r-&gt;io.file.autosync)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(r-&gt;io.file.fp);</span><br><span class="line">        redis_fsync(fileno(r-&gt;io.file.fp));</span><br><span class="line">        r-&gt;io.file.buffered = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看出来是有条件的调用了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">而如果使用BGSAVE命令，源码：</span><br><span class="line">```C</span><br><span class="line">void bgsaveCommand(client *c) &#123;</span><br><span class="line">    int schedule = 0;</span><br><span class="line"></span><br><span class="line">    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite</span><br><span class="line">     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */</span><br><span class="line">    if (c-&gt;argc &gt; 1) &#123;</span><br><span class="line">        if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;schedule&quot;)) &#123;</span><br><span class="line">            schedule = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line"></span><br><span class="line">    if (server.rdb_child_pid != -1) &#123;//正在rdb操作，本次操作不可以进行</span><br><span class="line">        addReplyError(c,&quot;Background save already in progress&quot;);</span><br><span class="line">    &#125; else if (server.aof_child_pid != -1) &#123; //正在aof操作本次操作不可以进行</span><br><span class="line">        if (schedule) &#123;</span><br><span class="line">            server.rdb_bgsave_scheduled = 1;</span><br><span class="line">            addReplyStatus(c,&quot;Background saving scheduled&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                &quot;An AOF log rewriting in progress: can&apos;t BGSAVE right now. &quot;</span><br><span class="line">                &quot;Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever &quot;</span><br><span class="line">                &quot;possible.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,&quot;Background saving started&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    pid_t childpid;</span><br><span class="line">    long long start;</span><br><span class="line"></span><br><span class="line">    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = time(NULL);</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line"></span><br><span class="line">    start = ustime();</span><br><span class="line">    if ((childpid = fork()) == 0) &#123; //在这里去fork一个新的进程进行持久化</span><br><span class="line">        int retval;</span><br><span class="line"></span><br><span class="line">        /* Child */</span><br><span class="line">        closeListeningSockets(0);</span><br><span class="line">        redisSetProcTitle(&quot;redis-rdb-bgsave&quot;);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        if (retval == C_OK) &#123;</span><br><span class="line">            size_t private_dirty = zmalloc_get_private_dirty(-1);</span><br><span class="line"></span><br><span class="line">            if (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    &quot;RDB: %zu MB of memory used by copy-on-write&quot;,</span><br><span class="line">                    private_dirty/(1024*1024));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server.child_info_data.cow_size = private_dirty;</span><br><span class="line">            sendChildInfo(CHILD_INFO_TYPE_RDB);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? 0 : 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Parent */</span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;fork&quot;,server.stat_fork_time/1000);</span><br><span class="line">        if (childpid == -1) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            serverLog(LL_WARNING,&quot;Can&apos;t save in background: fork: %s&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            return C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,&quot;Background saving started by pid %d&quot;,childpid);</span><br><span class="line">        server.rdb_save_time_start = time(NULL);</span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK; /* unreached */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码可以看出，bgsave命令是通过fork命令来进行后台的备份，而save命令会在原有的进程上进行操作，所以save命令要慎用，一旦使用了，如果redis中存储的数据比较多，全部dump到磁盘上，会使得redis服务器卡住一会。</p>
<p>在<figure class="highlight plain"><figcaption><span>rdb```对象。这个函数里面会把redis自己封装的```read```,```write```,```tell```,```flush```的函数指针赋值到rdb对象中。真正的写文件函数在下面的这个```rdbSaveRio```函数中实现。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">/* Produces a dump of the database in RDB format sending it to the specified</span><br><span class="line"> * Redis I/O channel. On success C_OK is returned, otherwise C_ERR</span><br><span class="line"> * is returned and part of the output, or all the output, can be</span><br><span class="line"> * missing because of I/O errors.</span><br><span class="line"> *</span><br><span class="line"> * When the function returns C_ERR and if &apos;error&apos; is not NULL, the</span><br><span class="line"> * integer pointed by &apos;error&apos; is set to the value of errno just after the I/O</span><br><span class="line"> * error. */</span><br><span class="line"> </span><br><span class="line">int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    dictIterator *di = NULL;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    char magic[10];</span><br><span class="line">    int j;</span><br><span class="line">    uint64_t cksum;</span><br><span class="line">    size_t processed = 0;</span><br><span class="line"></span><br><span class="line">    if (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    snprintf(magic,sizeof(magic),&quot;REDIS%04d&quot;,RDB_VERSION); //文件的头是一个魔数</span><br><span class="line">    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr; </span><br><span class="line">    if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;</span><br><span class="line">    //开始遍历数据库，一个个的开始进行持久化</span><br><span class="line">    for (j = 0; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        if (dictSize(d) == 0) continue;</span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        /* Write the SELECT DB opcode */</span><br><span class="line">        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,j) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">        /* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span><br><span class="line">         * is currently the largest type we are able to represent in RDB sizes.</span><br><span class="line">         * However this does not limit the actual size of the DB to load since</span><br><span class="line">         * these sizes are just hints to resize the hash tables. */</span><br><span class="line">        uint64_t db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,db_size) == -1) goto werr;</span><br><span class="line">        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">        /* Iterate this DB writing every entry */</span><br><span class="line">        while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            long long expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            if (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">            /* When this RDB is produced as part of an AOF rewrite, move</span><br><span class="line">             * accumulated diff from parent to child while rewriting in</span><br><span class="line">             * order to have a smaller final write. */</span><br><span class="line">            if (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = NULL; /* So that we don&apos;t release it again on error. */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we are storing the replication information on disk, persist</span><br><span class="line">     * the script cache as well: on successful PSYNC after a restart, we need</span><br><span class="line">     * to be able to process any EVALSHA inside the replication backlog the</span><br><span class="line">     * master will send us. */</span><br><span class="line">    if (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            if (rdbSaveAuxField(rdb,&quot;lua&quot;,3,body-&gt;ptr,sdslen(body-&gt;ptr)) == -1)</span><br><span class="line">                goto werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = NULL; /* So that we don&apos;t release it again on error. */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* EOF opcode */</span><br><span class="line">    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;</span><br><span class="line"></span><br><span class="line">    /* CRC64 checksum. It will be zero if checksum computation is disabled, the</span><br><span class="line">     * loading code skips the check in this case. */</span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    if (rioWrite(rdb,&amp;cksum,8) == 0) goto werr;</span><br><span class="line">    return C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    if (error) *error = errno;</span><br><span class="line">    if (di) dictReleaseIterator(di);</span><br><span class="line">    return C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个rdb文件的头是一个9个字节的魔数，总体如下格式：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dde91d8b97674?w=950&amp;h=93&amp;f=png&amp;s=4372" alt=""></p>
<p>魔数字后面的几个字段叫做AUX，存储的是redis的版本号，创建时间，已经使用的内存等等信息。<br>存储的格式如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167ddf4ba2f83272?w=643&amp;h=63&amp;f=png&amp;s=2543" alt=""></p>
<p>其中opcode是redis自己内部定义的一个操作码，用于表示这是一个什么类型的字段。具体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special RDB opcodes (saved/loaded with rdbSaveType/rdbLoadType). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_MODULE_AUX 247   <span class="comment">/* Module auxiliary data. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_IDLE       248   <span class="comment">/* LRU idle time. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_FREQ       249   <span class="comment">/* LFU frequency. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_AUX        250   <span class="comment">/* RDB aux field. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_RESIZEDB   251   <span class="comment">/* Hash table resize hint. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EXPIRETIME_MS 252    <span class="comment">/* Expire time in milliseconds. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EXPIRETIME 253       <span class="comment">/* Old expire time in seconds. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_SELECTDB   254   <span class="comment">/* DB number of the following keys. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_OPCODE_EOF        255   <span class="comment">/* End of the RDB file. */</span></span></span><br></pre></td></tr></table></figure></p>
<p>具体的AuxFields字段的填写代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* Save a few default AUX fields with information about the RDB generated. */</span><br><span class="line">int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;</span><br><span class="line">    int aof_preamble = (flags &amp; RDB_SAVE_AOF_PREAMBLE) != 0;</span><br><span class="line"></span><br><span class="line">    /* Add a few fields about the state when the RDB was created. */</span><br><span class="line">    if (rdbSaveAuxFieldStrStr(rdb,&quot;redis-ver&quot;,REDIS_VERSION) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;redis-bits&quot;,redis_bits) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;ctime&quot;,time(NULL)) == -1) return -1;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;used-mem&quot;,zmalloc_used_memory()) == -1) return -1;</span><br><span class="line"></span><br><span class="line">    /* Handle saving options that generate aux fields. */</span><br><span class="line">    if (rsi) &#123;</span><br><span class="line">        if (rdbSaveAuxFieldStrInt(rdb,&quot;repl-stream-db&quot;,rsi-&gt;repl_stream_db)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">        if (rdbSaveAuxFieldStrStr(rdb,&quot;repl-id&quot;,server.replid)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">        if (rdbSaveAuxFieldStrInt(rdb,&quot;repl-offset&quot;,server.master_repl_offset)</span><br><span class="line">            == -1) return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rdbSaveAuxFieldStrInt(rdb,&quot;aof-preamble&quot;,aof_preamble) == -1) return -1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained</span><br><span class="line"> * with strlen(). */</span><br><span class="line">ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) &#123;</span><br><span class="line">    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Wrapper for strlen(key) + integer type (up to long long range). */</span><br><span class="line">ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) &#123;</span><br><span class="line">    char buf[LONG_STR_SIZE];</span><br><span class="line">    int vlen = ll2string(buf,sizeof(buf),val);</span><br><span class="line">    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Save an AUX field. */</span><br><span class="line">ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) &#123;</span><br><span class="line">    ssize_t ret, len = 0;</span><br><span class="line">    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;</span><br><span class="line">    len += ret;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在下面的循环中，redis会遍历当前server中所有的db。然后把db中所有的dict都给保存下来,根据不同的格式，保存到文件的方式也是不一样的。<br>具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save a key-value pair, with expire time, type, key, value.</span></span><br><span class="line"><span class="comment"> * On error -1 is returned.</span></span><br><span class="line"><span class="comment"> * On success if the key was actually saved 1 is returned, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned (the key was already expired). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveKeyValuePair</span><span class="params">(rio *rdb, robj *key, robj *val, <span class="keyword">long</span> <span class="keyword">long</span> expiretime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savelru = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU;</span><br><span class="line">    <span class="keyword">int</span> savelfu = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the expire time */</span></span><br><span class="line">    <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveMillisecondTime(rdb,expiretime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the LRU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelru) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> idletime = estimateObjectIdleTime(val);</span><br><span class="line">        idletime /= <span class="number">1000</span>; <span class="comment">/* Using seconds is enough and requires less space.*/</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_IDLE) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,idletime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the LFU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelfu) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">1</span>];</span><br><span class="line">        buf[<span class="number">0</span>] = LFUDecrAndReturn(val);</span><br><span class="line">        <span class="comment">/* We can encode this in exactly two bytes: the opcode and an 8</span></span><br><span class="line"><span class="comment">         * bit counter, since the frequency is logarithmic with a 0-255 range.</span></span><br><span class="line"><span class="comment">         * Note that we do not store the halving time because to reset it</span></span><br><span class="line"><span class="comment">         * a single time when loading does not affect the frequency much. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_FREQ) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save type, key, value */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObjectType(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveStringObject(rdb,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObject(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Save the object type of object "o". */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveObjectType</span><span class="params">(rio *rdb, robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJ_STRING:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_STRING);</span><br><span class="line">    <span class="keyword">case</span> OBJ_LIST:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_SET:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INTSET)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_SET_INTSET);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_SET);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_ZSET:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_ZSET_2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_HASH:</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT)</span><br><span class="line">            <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_HASH);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJ_STREAM:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);</span><br><span class="line">    <span class="keyword">case</span> OBJ_MODULE:</span><br><span class="line">        <span class="keyword">return</span> rdbSaveType(rdb,RDB_TYPE_MODULE_2);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        serverPanic(<span class="string">"Unknown object type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* avoid warning */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-load的源码分析"><a href="#3-3-2-load的源码分析" class="headerlink" title="3.3.2 load的源码分析"></a>3.3.2 load的源码分析</h4><p>在服务启动的时候，如果conf配置文件中配置了save，那么redis就会去尝试加载一次rdb文件。源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function called at startup to load RDB or AOF file in memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadDataFromDisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime();</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadAppendOnlyFile(server.aof_filename) == C_OK)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from append only file: %.3f seconds"</span>,(<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi) == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from disk: %.3f seconds"</span>,</span><br><span class="line">                (<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Restore the replication ID / offset from the RDB file. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">                rsi.repl_id_is_set &amp;&amp;</span><br><span class="line">                rsi.repl_offset != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">                <span class="comment">/* Note that older implementations may save a repl_stream_db</span></span><br><span class="line"><span class="comment">                 * of -1 inside the RDB file in a wrong way, see more information</span></span><br><span class="line"><span class="comment">                 * in function rdbPopulateSaveInfo. */</span></span><br><span class="line">                rsi.repl_stream_db != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid,rsi.repl_id,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">                server.master_repl_offset = rsi.repl_offset;</span><br><span class="line">                <span class="comment">/* If we are a slave, create a cached master from this</span></span><br><span class="line"><span class="comment">                 * information, in order to allow partial resynchronizations</span></span><br><span class="line"><span class="comment">                 * with masters. */</span></span><br><span class="line">                replicationCacheMasterUsingMyself();</span><br><span class="line">                selectDb(server.cached_master,rsi.repl_stream_db);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal error loading the DB: %s. Exiting."</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">具体调用了```rdbLoad ```函数进行加载，这个函数实现：   </span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    startLoading(fp);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rsi,<span class="number">0</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到和read的流程一样，也是先把文件描述符封装为rio对象，然后调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">/* Load an RDB file from the rio stream &apos;rdb&apos;. On success C_OK is returned,</span><br><span class="line"> * otherwise C_ERR is returned and &apos;errno&apos; is set accordingly. */</span><br><span class="line">int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) &#123;</span><br><span class="line">    uint64_t dbid;</span><br><span class="line">    int type, rdbver;</span><br><span class="line">    redisDb *db = server.db+0;</span><br><span class="line">    char buf[1024];</span><br><span class="line"></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    if (rioRead(rdb,buf,9) == 0) goto eoferr;</span><br><span class="line">    buf[9] = &apos;\0&apos;;</span><br><span class="line">    if (memcmp(buf,&quot;REDIS&quot;,5) != 0) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;Wrong signature trying to load DB from file&quot;);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbver = atoi(buf+5);</span><br><span class="line">    if (rdbver &lt; 1 || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;Can&apos;t handle RDB format version %d&quot;,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Key-specific attributes, set by opcodes before the key type. */</span><br><span class="line">    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();</span><br><span class="line">    long long lru_clock = LRU_CLOCK();</span><br><span class="line">    </span><br><span class="line">    while(1) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line"></span><br><span class="line">        /* Read type. */</span><br><span class="line">        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;</span><br><span class="line"></span><br><span class="line">        /* Handle special types. */</span><br><span class="line">        if (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            /* EXPIRETIME: load an expire associated with the next key</span><br><span class="line">             * to load. Note that after loading an expire we need to</span><br><span class="line">             * load the actual type, and continue. */</span><br><span class="line">            expiretime = rdbLoadTime(rdb);</span><br><span class="line">            expiretime *= 1000;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            /* EXPIRETIME_MS: milliseconds precision expire times introduced</span><br><span class="line">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span><br><span class="line">            expiretime = rdbLoadMillisecondTime(rdb,rdbver);</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_FREQ) &#123;</span><br><span class="line">            /* FREQ: LFU frequency. */</span><br><span class="line">            uint8_t byte;</span><br><span class="line">            if (rioRead(rdb,&amp;byte,1) == 0) goto eoferr;</span><br><span class="line">            lfu_freq = byte;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_IDLE) &#123;</span><br><span class="line">            /* IDLE: LRU idle time. */</span><br><span class="line">            uint64_t qword;</span><br><span class="line">            if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;</span><br><span class="line">            lru_idle = qword;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            /* EOF: End of file, exit the main loop. */</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            /* SELECTDB: Select the specified database. */</span><br><span class="line">            if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;</span><br><span class="line">            if (dbid &gt;= (unsigned)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;FATAL: Data file was created with a Redis &quot;</span><br><span class="line">                    &quot;server configured to handle more than %d &quot;</span><br><span class="line">                    &quot;databases. Exiting\n&quot;, server.dbnum);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            /* RESIZEDB: Hint about the size of the keys in the currently</span><br><span class="line">             * selected data base, in order to avoid useless rehashing. */</span><br><span class="line">            uint64_t db_size, expires_size;</span><br><span class="line">            if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)</span><br><span class="line">                goto eoferr;</span><br><span class="line">            if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)</span><br><span class="line">                goto eoferr;</span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            continue; /* Read next opcode. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            /* AUX: generic string-string fields. Use to add state to RDB</span><br><span class="line">             * which is backward compatible. Implementations of RDB loading</span><br><span class="line">             * are requierd to skip AUX fields they don&apos;t understand.</span><br><span class="line">             *</span><br><span class="line">             * An AUX field is composed of two strings: key and value. */</span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line">            if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line"></span><br><span class="line">            if (((char*)auxkey-&gt;ptr)[0] == &apos;%&apos;) &#123;</span><br><span class="line">                /* All the fields with a name staring with &apos;%&apos; are considered</span><br><span class="line">                 * information fields and are logged at startup with a log</span><br><span class="line">                 * level of NOTICE. */</span><br><span class="line">                serverLog(LL_NOTICE,&quot;RDB &apos;%s&apos;: %s&quot;,</span><br><span class="line">                    (char*)auxkey-&gt;ptr,</span><br><span class="line">                    (char*)auxval-&gt;ptr);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-stream-db&quot;)) &#123;</span><br><span class="line">                if (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-id&quot;)) &#123;</span><br><span class="line">                if (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    memcpy(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+1);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;repl-offset&quot;)) &#123;</span><br><span class="line">                if (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,NULL,10);</span><br><span class="line">            &#125; else if (!strcasecmp(auxkey-&gt;ptr,&quot;lua&quot;)) &#123;</span><br><span class="line">                /* Load the script back in memory. */</span><br><span class="line">                if (luaCreateFunction(NULL,server.lua,auxval) == NULL) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        &quot;Can&apos;t load Lua script from RDB file! &quot;</span><br><span class="line">                        &quot;BODY: %s&quot;, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* We ignore fields we don&apos;t understand, as by AUX field</span><br><span class="line">                 * contract. */</span><br><span class="line">                serverLog(LL_DEBUG,&quot;Unrecognized RDB AUX field: &apos;%s&apos;&quot;,</span><br><span class="line">                    (char*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            continue; /* Read type again. */</span><br><span class="line">        &#125; else if (type == RDB_OPCODE_MODULE_AUX) &#123;</span><br><span class="line">            /* This is just for compatibility with the future: we have plans</span><br><span class="line">             * to add the ability for modules to store anything in the RDB</span><br><span class="line">             * file, like data that is not related to the Redis key space.</span><br><span class="line">             * Such data will potentially be stored both before and after the</span><br><span class="line">             * RDB keys-values section. For this reason since RDB version 9,</span><br><span class="line">             * we have the ability to read a MODULE_AUX opcode followed by an</span><br><span class="line">             * identifier of the module, and a serialized value in &quot;MODULE V2&quot;</span><br><span class="line">             * format. */</span><br><span class="line">            uint64_t moduleid = rdbLoadLen(rdb,NULL);</span><br><span class="line">            moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">            char name[10];</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line"></span><br><span class="line">            if (!rdbCheckMode &amp;&amp; mt == NULL) &#123;</span><br><span class="line">                /* Unknown module. */</span><br><span class="line">                serverLog(LL_WARNING,&quot;The RDB file contains AUX module data I can&apos;t load: no matching module &apos;%s&apos;&quot;, name);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125; else if (!rdbCheckMode &amp;&amp; mt != NULL) &#123;</span><br><span class="line">                /* This version of Redis actually does not know what to do</span><br><span class="line">                 * with modules AUX data... */</span><br><span class="line">                serverLog(LL_WARNING,&quot;The RDB file contains AUX module data I can&apos;t load for the module &apos;%s&apos;. Probably you want to use a newer version of Redis which implements aux data callbacks&quot;, name);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* RDB check mode. */</span><br><span class="line">                robj *aux = rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line">                decrRefCount(aux);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Read key */</span><br><span class="line">        if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;</span><br><span class="line">        /* Read value */</span><br><span class="line">        if ((val = rdbLoadObject(type,rdb)) == NULL) goto eoferr;</span><br><span class="line">        /* Check if the key already expired. This function is used when loading</span><br><span class="line">         * an RDB file from disk, either at startup, or when an RDB was</span><br><span class="line">         * received from the master. In the latter case, the master is</span><br><span class="line">         * responsible for key expiry. If we would expire keys here, the</span><br><span class="line">         * snapshot taken by the master may not be reflected on the slave. */</span><br><span class="line">        if (server.masterhost == NULL &amp;&amp; !loading_aof &amp;&amp; expiretime != -1 &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* Add the new object in the hash table */</span><br><span class="line">            dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">            /* Set the expire time if needed */</span><br><span class="line">            if (expiretime != -1) setExpire(NULL,db,key,expiretime);</span><br><span class="line">            </span><br><span class="line">            /* Set usage information (for eviction). */</span><br><span class="line">            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock);</span><br><span class="line"></span><br><span class="line">            /* Decrement the key refcount since dbAdd() will take its</span><br><span class="line">             * own reference. */</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Reset the state that is key-specified and is populated by</span><br><span class="line">         * opcodes before the key, so that we start from scratch again. */</span><br><span class="line">        expiretime = -1;</span><br><span class="line">        lfu_freq = -1;</span><br><span class="line">        lru_idle = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Verify the checksum if RDB version is &gt;= 5 */</span><br><span class="line">    if (rdbver &gt;= 5) &#123;</span><br><span class="line">        uint64_t cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        if (rioRead(rdb,&amp;cksum,8) == 0) goto eoferr;</span><br><span class="line">        if (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            if (cksum == 0) &#123;</span><br><span class="line">                serverLog(LL_WARNING,&quot;RDB file was saved with checksum disabled: no check performed.&quot;);</span><br><span class="line">            &#125; else if (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,&quot;Wrong RDB checksum. Aborting now.&quot;);</span><br><span class="line">                rdbExitReportCorruptRDB(&quot;RDB CRC error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK;</span><br><span class="line"></span><br><span class="line">eoferr: /* unexpected end of file is handled here with a fatal exit */</span><br><span class="line">    serverLog(LL_WARNING,&quot;Short read or OOM loading DB. Unrecoverable error, aborting now.&quot;);</span><br><span class="line">    rdbExitReportCorruptRDB(&quot;Unexpected EOF reading RDB file&quot;);</span><br><span class="line">    return C_ERR; /* Just to avoid warning */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>通过上面的源码分析看出来RDB方式有如下优缺点  </p>
<ul>
<li><p>优点：<br>1.通过fork命令创建后台子进程来进行异步操作，全量保存到文件中；  </p>
</li>
<li><p>缺点：<br>1.如果使用save命令来保存，是同步操作，因为redis是单线程，导致工作线程卡住，redis卡顿；<br>2.在fork进程后，如果再有客户端发起写操作，会导致这部分数据没有及时的同步到RDB文件中，只有等这次RDB的dump操作结束后，下一次操作的时候持久化。<br>为了解决这个问题，redis就引入了另外一种持久化方式—-AOF。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/" data-id="cjqes54je0004tkkps43us5gw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          redis个人源码分析笔记3(redis的事件驱动源码分析)
        
      </div>
    </a>
  
  
    <a href="/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">redis个人源码分析笔记1----hyperloglog（golang实现）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/redis源码分析笔记/">redis源码分析笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记2(dict的实现原理)/">redis个人源码分析笔记2(dict的实现原理)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记3(redis的事件驱动源码分析)/">redis个人源码分析笔记3(redis的事件驱动源码分析)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记5(RDB持久化机制)/">redis个人源码分析笔记5(RDB持久化机制)</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记1(hyperloglog+golang实现)/">redis个人源码分析笔记1----hyperloglog（golang实现）</a>
          </li>
        
          <li>
            <a href="/2019/01/02/redis个人源码分析笔记4(hash对象的存储)/">redis个人源码分析笔记4(hash对象的存储)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lin-Hao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>